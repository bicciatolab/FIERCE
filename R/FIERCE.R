################################################################################
####################              FIERCE                    ####################
################################################################################

#' @title set_FIERCE_workspace
#'
#' @description Sets the current R workspace for the FIERCE pipeline, with all the helper functions that are necessary to interface R with python. This function must be always launched before using FIERCE
#'
#' @return The function loads in the current R workspace all the necessary helper functions
#'
#' @examples
#' Simply launch the function with no arguments
#'
#' set_FIERCE_workspace()
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

set_FIERCE_workspace <- function() {
  library(reticulate)
  use_condaenv("FIERCE")
  source_python(system.file("inter_environment_utils.py", package = "FIERCE", lib.loc= .libPaths()),envir=globalenv())
  move_plots <- function(project_dir, subfolder) {
    if (dir.exists("figures") == TRUE) {
      for (i in dir("figures")) {
        file.copy(paste0('./figures/', i), paste0(project_dir, "/", subfolder, "/", i), overwrite=TRUE)
      }
      unlink("figures", recursive=TRUE)
    }
  }
  assign("move_plots", move_plots, envir=.GlobalEnv)
  rename_plots <- function(project_dir, subfolder) {
    files_to_rename <- dir(paste0(project_dir, "/", subfolder))[grep("scvelo_",dir(paste0(project_dir, "/", subfolder)))]
    for (j in files_to_rename) {
      new_name <- strsplit(j, split="scvelo_")[[1]][2]
      file.rename(paste0(project_dir, "/", subfolder, "/", j), paste0(project_dir, "/", subfolder, "/", new_name))
    }
  }
  assign("rename_plots", rename_plots, envir=.GlobalEnv)
}


#' @title load_test_dataset
#'
#' @description Loads the specified test dataset
#'
#' @param dataset name of the test dataset to load. Can be "pancreas" or "dentate_gyrus"
#'
#' @return anndata object of the selected test dataset
#'
#' @examples
#' test_dataset <- load_test_dataset("pancreas")
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

load_test_dataset <- function(dataset){
  test_dataset <- load_h5ad(system.file("data",paste0(dataset, "_test_sample.h5ad"), package= "FIERCE"))
  return(test_dataset)
}


#' @title save_h5ad
#'
#' @description Saves anndata object to h5ad file
#'
#' @param adata anndata object
#' @param file_name name of h5ad output file (including its path)
#'
#' @return No objects are returned. The h5ad file containing the anndata object will be saved in the destination specified in the file name
#'
#' @examples
#' save_h5ad(adata, "./anndata_object.h5ad")
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export

save_h5ad <- function(adata, file_name) {
  adata$write(file_name)
}


#' @title load_h5ad
#'
#' @description Loads anndata object from h5ad file
#'
#' @param file_name name of h5ad file (including its path)
#'
#' @return anndata object contained in the h5ad file
#'
#' @examples
#' adata <- load_h5ad("./anndata_object.h5ad")
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

load_h5ad <- function(file_name){
  sc <- import("scanpy")
  adata <- sc$read(file_name)
  return(adata)
}

#' @title build_adata_object
#'
#' @description Creates a new anndata object from a loom file generated by velocyto. Spliced and unspliced read counts will be stored into separate layers. If not provided by the user, the gene expression matrix (slot "X") of the anndata object will correspond to spliced counts. Optionally, the anndata object can be integrated with a Seurat object, to retrieve useful information such as cell annotations and dimension reductions; these can also be directly provided by the user as separate data frames
#'
#' @param loom_file name of the loom file generated by velocyto (including its path). More than one file can be specified with a character vector; in this case, the new anndata object will include all the samples merged together
#' @param adata_object alternatively to creating a brand new anndata object, a pre-existing anndata object can be provided and modified through the options below. Useful for modifying any anndata object on the fly
#' @param Seurat_object optional Seurat object to be integrated with the new anndata object. WARNING: if a Seurat object is provided, only the cells and the genes stored in its active assay will be kept in the new anndata object, the remaining will be discarded
#' @param replace_matrix boolean; if TRUE, the expression matrix stored in the active assay of the provided Seurat object will be stored in the "X" slot of the anndata object; if FALSE (default), the spliced counts from the loom file will be used instead
#' @param matrix_slot only used if replace_matrix=TRUE; slot of the active assay of the Seurat object from which the expression matrix has to be retrieved ("counts" by default, set to "data" if interested in the normalized counts)
#' @param subset_key_Seurat optional; name of the column of the "meta.data" slot to consider if the user is exclusively interested in a particular subset of the Seurat object (see subset_ident_Seurat)
#' @param subset_ident_Seurat character vector containing the cell identities to keep in the subset of the Seurat object, amongst those included in the column specified in subset_key_Seurat
#' @param active_assay name of the active assay of the Seurat object; by default, the current active assay will be considered
#' @param Seurat_cellnames_prefix character vector containing the complete list of all the unique strings preceding the barcodes in the cell names of the Seurat object; necessary to adapt the nomenclature of the Seurat object to the nomenclature of the anndata object. WARNING: each unique string must be specified only once, but all strings need to be exact, an error will be thrown otherwise. This parameter does not need to be specified if the barcodes are not preceded by any string
#' @param Seurat_cellnames_suffix character vector containing the complete list of all the unique strings following the barcodes in the cell names of the Seurat object; necessary to adapt the nomenclature of the Seurat object to the nomenclature of the anndata object. WARNING: each unique string must be specified only once, but all strings need to be exact, an error will be thrown otherwise. This parameter does not need to be specified if the barcodes are not followed by any string
#' @param sample_column name of the column of the "meta.data" slot of the Seurat object containing the sample identity of each cell; necessary to adapt the nomenclature of the Seurat object to the nomenclature of the anndata object. WARNING: for each single cell, the sample identity MUST correspond to the name of the respective loom file (without the ".loom" extension), an error will be thrown otherwise
#' @param metadata_keys character vector containing the list of the columns of the "meta.data" slot of the Seurat object (cell annotations) that need to be transferred to the "obs" slot of the new anndata object
#' @param reduction_keys character vector containing the list of the dimension reductions of the Seurat object that need to be transferred to the "obsm" slot of the new anndata object
#' @param subset_key_anndata optional; name of the cell annotation in the "obs" slot to consider if the user is exclusively interested in a particular subset of the anndata object (see subset_ident_anndata)
#' @param subset_ident_anndata character vector containing the cell identities to keep in the subset of the anndata object, amongst those that are included in the annotation specified in subset_key_anndata
#' @param cells_to_keep optional character vector containing the names of the cells to exclusively include in the new anndata object. Cell names need to be in loom format: <sample_name>:<cell_barcode>x
#' @param genes_to_keep optional character vector containing the names of the genes to exclusively include in the new anndata object
#' @param user_metadata optional user-provided data frame containing additional cell annotations to include in the "obs" slot of the new anndata object. The row names of the data frame must correspond exactly to the cell names ("obs_names" slot) of the new anndata object (as well as to the cell names of the active assay of the Seurat object if provided). Also, they need to be in loom format: <sample_name>:<cell_barcode>x
#' @param user_embedding optional user-provided data frame containing an additional dimension reduction to include in the "obsm" slot of new anndata object. The data frame must include a separate column for each dimension, and the row names must correspond exactly to the cell names ("obs_names" slot) of the new anndata object (as well as to the cell names of the active assay of the Seurat object if provided)
#' @param user_embedding_name name of the additional dimension reduction provided in user_embedding
#'
#' @return The new anndata object, optionally integrated with the user-provided Seurat object, annotations and dimension reductions
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @examples
#' #Simply generate an anndata object from a single loom file with no additional operations
#'
#' adata <- build_adata_object("./sample_name/sample_name.loom")
#'
#' #Generate a merged anndata object from two separate loom files and integrate it with a Seurat object. The latter includes multiple samples merged together, but ONLY two of them (Sample1 and Sample2) will be included in the new anndata object. Note that the column of the "meta.data" slot specified in sample_column and the names of the loom files MUST follow the same nomenclature. Several cell annotations and dimension reductions are retrieved from the Seurat object. The unique strings preceding and following the barcodes in the cell names of the Seurat object are accurately specified to allow the integration with the anndata object
#'
#' adata <- build_adata_object(loom_file=c("./Sample1/Sample1.loom", "./Sample2/Sample2.loom"), Seurat_object=name_of_Seurat_object, replace_matrix=TRUE, matrix_slot="counts", subset_key_Seurat="Sample", subset_ident_Seurat=c("Sample1", "Sample2"), Seurat_cellnames_prefix=c("Sample1_", "Sample2_"), Seurat_cellnames_suffix=c("-1"), sample_column="Sample", metadata_keys=c("Sample", "Clusters", "Cell_cycle_phase"), reduction_keys=c("pca", "umap"))
#'
#' #Generate an anndata object from a single loom file and include additional user-provided cell annotations and dimension reductions. Only the cells and the genes specified in the respective character vectors are included. Note that the row names of the additional data frames provided by the user MUST correspond exactly to the cell names specified in cells_to_keep
#'
#' adata <- build_adata_object(loom_file="./sample_name/sample_name.loom", cells_to_keep=cell_names_vector, genes_to_keep=gene_names_vector, user_metadata=annotation_data_frame, user_embedding=dimension_reduction_data_frame, user_embedding_name="new_dimension_reduction")
#'
#' @export
#'

build_adata_object <- function(loom_file=NULL, adata_object=NULL, Seurat_object=NULL, replace_matrix=FALSE, matrix_slot="counts", subset_key_Seurat=NULL, subset_ident_Seurat=NULL, active_assay=NULL, Seurat_cellnames_prefix=NULL, Seurat_cellnames_suffix=NULL, sample_column=NULL, metadata_keys=NULL, reduction_keys=NULL, subset_key_anndata=NULL, subset_ident_anndata=NULL, cells_to_keep=NULL, genes_to_keep=NULL, user_metadata=NULL, user_embedding=NULL, user_embedding_name=NULL) {
  anndata <- import("anndata")
  if (!is.null(Seurat_object)) {
    library(Seurat)
  }

  if (is.null(adata_object)) {

    from_looms <- "from_looms"

    if (is.null(loom_file)) {
      stop("Neither loom file path nor adata object provided")
    }

    cat("Generating anndata object from loom file(s)...")
    cat("\n")

    c <- 0

    for (i in 1:length(loom_file)) {

    	cat(paste0("Parsing ", loom_file[i]))
      cat("\n")

		  adata_object_i <- anndata$read_loom(loom_file[i])
      adata_object_i$var_names_make_unique()

    	if (!is.null(cells_to_keep)) {
    		cells <- adata_object_i$obs_names$tolist()[adata_object_i$obs_names$tolist()%in%cells_to_keep]
        if (length(cells)==0) {
          cat(paste0("Skipping ", loom_file[i]))
          cat("\n")
        }
        if (length(cells)==0) next
        adata_object_i <- subset_anndata_cells(adata_object_i, cells)
    	}

    	if (!is.null(genes_to_keep)) {
        genes <- adata_object_i$var_names$tolist()[adata_object_i$var_names$tolist()%in%genes_to_keep]
    		adata_object_i <- subset_anndata_genes(adata_object_i, genes)
    	}

      add_layer(adata_object_i, adata_object_i$layers['spliced'], 'spliced', transpose=F, compress=T)
      add_layer(adata_object_i, adata_object_i$layers['unspliced'], 'unspliced', transpose=F, compress=T)

      if (replace_matrix==FALSE) {
        add_X(adata_object_i, adata_object_i$X, transpose=F, compress=T)
      }

      delete_layer(adata_object_i, 'matrix')
      delete_layer(adata_object_i, 'ambiguous')

      if (i==1 | !exists("adata_object")) {
        adata_object <- adata_object_i$copy()
      } else {
        adata_object <- adata_object$concatenate(adata_object_i)
        c <- c+1
      }
    }
    if (length(loom_file)>1 & c>0) {
    	old_cell_names <- adata_object$obs_names$tolist()
      old_cell_names_list <- strsplit(old_cell_names, split="-")
    	new_cell_names <- NULL
    	for (i in 1:length(old_cell_names)) {
        	new_cell_names <- c(new_cell_names, old_cell_names_list[[i]][1])
    	}
    	replace_cell_names(adata_object, new_cell_names)
	  }
  }

  #Optional integration with Seurat object

  if (!is.null(Seurat_object)) {

    cat("Integrating with provided Seurat object...")
    cat("\n")

    if (!is.null(active_assay)) {
      DefaultAssay(Seurat_object) <- active_assay
    }

    #Optional subset of Seurat object

    if (!is.null(subset_key_Seurat)) {
      Idents(Seurat_object) <- Seurat_object@meta.data[,subset_key_Seurat]
      if (!is.null(subset_ident_Seurat)) {
        Seurat_object <- subset(Seurat_object, idents=subset_ident_Seurat)
      } else {
        stop("Identity to keep not specified for Seurat object")
      }
    }

    #Subset of anndata object

    new_cell_names <- colnames(Seurat_object)

    if (!is.null(Seurat_cellnames_prefix)) {
      for (i in Seurat_cellnames_prefix) {
        if (length(grep(i, new_cell_names))==0) {
			    stop(paste0(i, " is an invalid cellname prefix"))
		    }
        new_cell_names <- gsub(i, "", new_cell_names)
      }
    }
    if (!is.null(Seurat_cellnames_suffix)) {
      for (i in Seurat_cellnames_suffix) {
        if (length(grep(i, new_cell_names))==0) {
			    stop(paste0(i, " is an invalid cellname suffix"))
		    }
        new_cell_names <- gsub(i, "x", new_cell_names)
      }
    }
    if (is.null(sample_column)) {
      stop("Missing name of sample column in Seurat object")
    }

    new_cell_names <- paste0(as.character(Seurat_object@meta.data[,sample_column]), ":", new_cell_names)

    adata_object <- subset_anndata_cells(adata_object, new_cell_names)
    if (sum(adata_object$obs_names$tolist()==new_cell_names) != length(new_cell_names)){
      stop("Order of cells in anndata object is different from order of cells in Seurat object")
    }

    subset_genes <- rownames(Seurat_object)[rownames(Seurat_object) %in% adata_object$var_names$tolist()]
    adata_object <- subset_anndata_genes(adata_object, subset_genes)

    #Add metadata and reductions

    if (!is.null(metadata_keys)) {
      cat("Retrieving cell annotations from Seurat object...")
      cat("\n")
      for (i in metadata_keys) {
        add_annotation_obs(adata_object, Seurat_object@meta.data[,i], i)
      }
    }
    if (!is.null(reduction_keys)) {
      cat("Retrieving embedding coordinates from Seurat object...")
      cat("\n")
      for (i in reduction_keys) {
        add_obsm(adata_object, Seurat_object@reductions[[i]]@cell.embeddings, paste0("X_", i))
      }
    }

    #Optional replacement of expression matrix

    if (replace_matrix==TRUE) {
      cat("Retrieving gene expression matrix from Seurat object...")
      cat("\n")
      if (matrix_slot=="counts") {
        add_X(adata_object, matrix(as.numeric(GetAssay(subset(Seurat_object, features=subset_genes), DefaultAssay(Seurat_object))@counts), ncol=ncol(GetAssay(subset(Seurat_object, features=subset_genes), DefaultAssay(Seurat_object))@counts)), transpose=T, compress=T)
      } else {
        add_X(adata_object, matrix(as.numeric(GetAssay(subset(Seurat_object, features=subset_genes), DefaultAssay(Seurat_object))@data), ncol=ncol(GetAssay(subset(Seurat_object, features=subset_genes), DefaultAssay(Seurat_object))@data)), transpose=T, compress=T)
      }
    }
  }

  #Optional subset of anndata object

  if (!is.null(subset_key_anndata)) {
    cat("Subsetting anndata object (identities)...")
    cat("\n")
    if (!is.null(subset_ident_anndata)) {
      all_cells <- adata_object$obs_names$tolist()
      chosen_cells <- all_cells[adata_object$obs[subset_key_anndata][,subset_key_anndata] %in% subset_ident_anndata]
      adata_object <- subset_anndata_cells(adata_object, chosen_cells)
    } else {
      stop("Identity to keep not specified for anndata object")
    }
  }

  if (!exists("from_looms") & !is.null(cells_to_keep)) {
    cat("Subsetting anndata object (cells)...")
    cat("\n")
    adata_object <- subset_anndata_cells(adata_object, cells_to_keep)
  }

  if (!exists("from_looms") & !is.null(genes_to_keep)) {
    cat("Subsetting anndata object (genes)...")
    cat("\n")
    adata_object <- subset_anndata_cells(adata_object, genes_to_keep)
  }

  #Optional external metadata

  if (!is.null(user_metadata)) {
    cat("Integrating user-provided cell annotations...")
    cat("\n")
    for (i in colnames(user_metadata)) {
      add_annotation_obs(adata_object, user_metadata[,i], i)
    }
  }

  #Optional external embedding

  if (!is.null(user_embedding)) {
    cat("Integrating user-provided embedding coordinates...")
    cat("\n")
    if (!is.null(user_embedding_name)) {
      add_obsm(adata_object, user_embedding, paste0("X_", user_embedding_name))
    } else {
      stop("External embedding name missing")
    }
  }
  return(adata_object)
}


#' @title perform_preprocessing
#'
#' @description Performs a full Scanpy analysis (optional) pipeline on the expression matrix (slot "X") of the provided anndata object, from quality checks to clustering. By tuning the appropriate parameters, the user is free to personalize the analysis and perform only the desired operations
#'
#' @param adata anndata object
#' @param project_dir name of the directory containing the results of the main FIERCE analysis (including the path). If it does not exist, it will be created. The default name is "./FIERCE_results". The plots of the Scanpy pipeline will be saved in the "scanpy_preprocessing" sub-directory
#' @param min_genes minimum number of expressed genes required for a cell to be retained in the anndata object
#' @param min_cells minimum number of expressing cells required for a gene to be retained in the anndata object
#' @param compute_QC_metrics boolean; whether to compute quality metrics on cells. TRUE by default
#' @param compute_MT_fraction boolean; whether to include the mitochondrial fraction in quality metrics. TRUE by default
#' @param MT_prefix prefix of mitochondrial genes. "MT-" (human) by default
#' @param UMI_lower_thr minimum number of total UMI counts required for a cell to be retained in the anndata object
#' @param UMI_upper_thr maximum number of total UMI counts allowed for a cell to be retained in the anndata object
#' @param Gene_lower_thr minimum number of expressed genes (by counts) required for a cell to be retained in the anndata object
#' @param Gene_upper_thr maximum number of expressed genes (by counts) allowed for a cell to be retained in the anndata object
#' @param MTf_lower_thr minimum mitochondrial fraction required for a cell to be retained in the anndata object
#' @param MTf_upper_thr maximum mitochondrial fraction allowed for a cell to be retained in the anndata object
#' @param do_normalization boolean; whether to perform library size normalization on cells. TRUE by default
#' @param target_sum_for_norm scale factor for library size normalization. 1e4 by default
#' @param do_log_transform boolean; whether to log-transform the expression matrix after normalization. TRUE by default
#' @param cell_cycle_scoring boolean; whether to perform cell cycle scoring on cells. FALSE by default. If TRUE, cell cycle genes must be provided by the user
#' @param s_genes character vector containing the S phase genes. Only used if cell_cycle_scoring=TRUE
#' @param g2m_genes character vector containing the G2M phase genes. Only used if cell_cycle_scoring=TRUE
#' @param find_HVGs boolean; whether to identify highly variable genes. TRUE by default
#' @param min_mean_HVGs lower cutoff for the mean of highly variable genes. Only used if find_HVGs=TRUE and n_top_HVGs=NULL. Default is 0.0125
#' @param max_mean_HVGs upper cutoff for the mean of highly variable genes. Only used if find_HVGs=TRUE and n_top_HVGs=NULL. Default is 3
#' @param min_disp_HVGs lower cutoff for the normalized dispersion of highly variable genes. Only used if find_HVGs=TRUE and n_top_HVGs=NULL. Default is 0.5
#' @param max_disp_HVGs upper cutoff for the normalized dispersion of highly variable genes. Only used if find_HVGs=TRUE and n_top_HVGs=NULL. Default is Inf
#' @param n_top_HVGs number of top variable genes to keep. Overrides all cutoffs specified for mean and normalized dispersion. Mandatory if flavor_HVGs="seurat_v3"
#' @param flavor_HVGs flavor for highly variable genes computation. Choose between "seurat", "cell_ranger" or "seurat_v3". Only used if find_HVGs=TRUE. Default is "seurat"
#' @param subset_HVGs boolean; whether to subset the anndata object to retain only the highly variable genes. Only used if find_HVGs=TRUE. Default is FALSE
#' @param perform_PCA boolean; whether to perform PCA. Default is TRUE
#' @param plot_PCA_heatmap boolean; whether to plot the heatmap of the expression of the most significant genes for each PC. Default is TRUE
#' @param scale_data boolean; whether to perform data scaling before PCA. Only used if perform_PCA=TRUE. Default is TRUE. WARNING: scaling is performed just for PCA, the expression matrix in the "X" slot will remain unscaled
#' @param perform_regression boolean; whether to perform a regression procedure during data scaling. Only used if perform_PCA=TRUE and scale_data=TRUE. Default is FALSE
#' @param regress_vars character vector containing the names of the numerical variables in the "obs" slot to include in the (optional) regression procedure. NULL by default
#' @param compute_neighbor_graph boolean; whether to compute the nearest neighbor graph on the PC space. Default is TRUE
#' @param n_neighbors number of nearest neighbors to compute for each cell in the nearest neighbor graph. Only used if compute_neighbor_graph=TRUE. Default is 30 neighbors
#' @param n_pcs number of PCs to consider for the nearest neighbor graph computation. Only used if compute_neighbor_graph=TRUE. Default (NULL) is all the computed PCs
#' @param perform_clustering boolean; whether to perform clustering analysis ("Leiden" algorithm). Default is TRUE. WARNING: a nearest neighbor graph must be computed first
#' @param perform_UMAP boolean; whether to compute UMAP embedding. Default is TRUE. WARNING: a nearest neighbor graph must be computed first
#' @param color_as character vector containing the names of the cell annotations in the "obs" slot to visualize on the PCA and UMAP plots. If present, the results of the clustering analysis will be visualized by default
#' @param lab_order optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the order by which the respective labels should be printed in the legends of PCA and UMAP plots. If it is not necessary to specify a particular order for a specific annotation, just write NULL. If it is not necessary to specify any order for any annotation, do not change the default value of this parameter
#' @param palette optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the colors of the respective labels. If it is not necessary to specify any color for a specific annotation, just write NULL; in this case, a default color palette will be used. If it is not necessary to specify any color for any annotation, do not change the default value of this parameter; in this case, annotations will be colored according either to a default palette, or to the colors that are already stored in the anndata object ("uns" slot)
#' @param legend_loc localization of the legend on the PCA and UMAP plots. Default is "right margin"
#' @param alpha transparency of the dots on the PCA and UMAP plots, ranging from 0 (fully transparent) to 1 (fully opaque). Default is 1
#' @param add_outline whether to add an outline around groups of dots on the PCA and UMAP plots. Default is FALSE
#' @param find_DEGs boolean; whether to find the differentially expressed genes (DEGs) between the groups defined in groups_for_DEGs. Default is TRUE
#' @param groups_for_DEGs name of the cell annotation in the "obs" slot to use as grouping variable for DEGs analysis. If present, the results of the clustering analysis will be used. If clustering analysis has not been performed, and the user does not specify an alternative grouping variable, the DEGs analysis will be skipped
#' @param method_for_DEGs method to use for DEGs analysis. Choose between "logreg", "t-test", "wilcoxon" or "t-test_overestim_var". Default is "wilcoxon"
#' @param DEGs_to_show number of DEGs to plot. Default is 25
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis
#'
#' @examples
#' #Perform a complete analysis with default values
#'
#' perform_preprocessing(adata)
#'
#' #Perform a complete analysis after setting thresholds for QC metrics
#'
#' perform_preprocessing(adata, min_genes=200, min_cells=3, UMI_lower_thr=1000, UMI_upper_thr=20000, Gene_lower_thr=500, Gene_upper_thr=6500, MTf_upper_thr=0.2)
#'
#' #Perform a partial analysis on an anndata object that already contains pre-computed PCs: perform only clustering, UMAP and DEGs, skip all previous steps. Create a new anndata object with the results of the analysis
#'
#' adata_preprocessed <- perform_preprocessing(adata, compute_QC_metrics=FALSE, do_normalization=FALSE, do_log_transform=FALSE, find_HVGs=FALSE, perform_PCA=FALSE, adata_copy=TRUE)
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

perform_preprocessing <- function(adata, project_dir="./FIERCE_results", min_genes=NULL, min_cells=NULL, compute_QC_metrics=TRUE, compute_MT_fraction=TRUE, MT_prefix='MT-', UMI_lower_thr=NULL, UMI_upper_thr=NULL, Gene_lower_thr=NULL, Gene_upper_thr=NULL, MTf_lower_thr=NULL, MTf_upper_thr=NULL, do_normalization=TRUE, target_sum_for_norm=1e4, do_log_transform=TRUE, cell_cycle_scoring=FALSE, s_genes=NULL, g2m_genes=NULL, find_HVGs=TRUE, min_mean_HVGs=0.0125, max_mean_HVGs=3, min_disp_HVGs=0.5, max_disp_HVGs=Inf, n_top_HVGs=NULL, flavor_HVGs='seurat', subset_HVGs=FALSE, perform_PCA=TRUE, plot_PCA_heatmap=TRUE, scale_data=TRUE, perform_regression=FALSE, regress_vars=NULL, compute_neighbor_graph=TRUE, n_neighbors=30, n_pcs=NULL, perform_clustering=TRUE, perform_UMAP=TRUE, color_as=NULL, lab_order=NULL, palette=NULL, legend_loc="right margin", alpha=1, add_outline=FALSE, find_DEGs=TRUE, groups_for_DEGs=NULL, method_for_DEGs='wilcoxon', DEGs_to_show=25, adata_copy=FALSE) {
  sc <- import("scanpy")

  if (dir.exists(project_dir) == FALSE) {
    dir.create(project_dir)
  }

  if (dir.exists(paste0(project_dir, "/scanpy_preprocessing")) == FALSE) {
    dir.create(paste0(project_dir, "/scanpy_preprocessing"))
  }

  if (adata_copy == TRUE) {
    adata <- adata$copy()
  }

  cat("Now printing Scanpy output messages...")
  cat("\n")

  #Basic filtering

  if (!is.null(min_genes)) {
    sc$pp$filter_cells(adata, min_genes=as.numeric(min_genes))
  }

  if (!is.null(min_cells)) {
    sc$pp$filter_genes(adata, min_cells=as.numeric(min_cells))
  }

  #QC metrics

  if (compute_QC_metrics==TRUE) {
    qc_vars <- as.character()
    vars_to_plot <- c('n_genes_by_counts', 'total_counts')
    if (compute_MT_fraction==TRUE) {
      adata$var['mt'] <- adata$var_names$str$startswith(MT_prefix)
      qc_vars <- list(as.character('mt'))
      vars_to_plot <- c('n_genes_by_counts', 'total_counts', 'pct_counts_mt')
    }

    sc$pp$calculate_qc_metrics(adata, qc_vars=qc_vars, percent_top=NULL, log1p=FALSE, inplace=TRUE)

#    prova <- file("log.txt", open = "a")
#    sink(prova, type = "message")

    sc$pl$violin(adata, vars_to_plot, jitter=as.numeric(0.4), multi_panel=TRUE, scale='count', save='_QC_metrics.pdf')
    move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")

#    sink()

    if (compute_MT_fraction==TRUE) {
      sc$pl$scatter(adata, x='total_counts', y='pct_counts_mt', save='_UMI_MTf.pdf')
      sc$pl$scatter(adata, x='n_genes_by_counts', y='pct_counts_mt', save='_Gene_MTf.pdf')
      sc$pl$scatter(adata, x='total_counts', y='n_genes_by_counts', save='_UMI_Gene.pdf')
      move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
    } else {
      sc$pl$scatter(adata, x='total_counts', y='n_genes_by_counts', save='_UMI_Gene.pdf')
      move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
    }

#    sink()
  }

  #Advanced filtering

  if (!is.null(UMI_lower_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$total_counts$tolist() >= as.numeric(UMI_lower_thr)])
  }
  if (!is.null(UMI_upper_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$total_counts$tolist() <= as.numeric(UMI_upper_thr)])
  }
  if (!is.null(Gene_lower_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$n_genes_by_counts$tolist() >= as.numeric(Gene_lower_thr)])
  }
  if (!is.null(Gene_upper_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$n_genes_by_counts$tolist() <= as.numeric(Gene_upper_thr)])
  }
  if (!is.null(MTf_lower_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$pct_counts_mt$tolist() >= as.numeric(MTf_lower_thr)])
  }
  if (!is.null(MTf_upper_thr)) {
    adata <- subset_anndata_cells(adata, adata$obs_names$tolist()[adata$obs$pct_counts_mt$tolist() <= as.numeric(MTf_upper_thr)])
  }

  #normalization

  if (do_normalization==TRUE) {
    sc$pp$normalize_total(adata, target_sum=as.integer(target_sum_for_norm))
  }
  if (do_log_transform==TRUE) {
    sc$pp$log1p(adata)
  }

  #Cell cycle scoring

  if (cell_cycle_scoring==TRUE) {
    if (is.null(s_genes) | is.null(g2m_genes)) {
      cell_cycle_scoring <- FALSE
      cat("WARNING: No lists provided for cell cycle genes - skipping cell cycle scoring")
      cat("\n")
    } else {
      sc$tl$score_genes_cell_cycle(adata, s_genes=s_genes, g2m_genes=g2m_genes)
    }
  }

  #HVGs

  if (find_HVGs==TRUE) {
    if (check_uns(adata,"log1p")=="Yes") {
      log1p_correction(adata)
    }
    if (!is.null(n_top_HVGs)) {
      n_top_HVGs <- as.integer(n_top_HVGs)
    }
    sc$pp$highly_variable_genes(adata, min_mean=as.numeric(min_mean_HVGs), max_mean=as.numeric(max_mean_HVGs), min_disp=as.numeric(min_disp_HVGs), max_disp=as.numeric(max_disp_HVGs), n_top_genes=n_top_HVGs, flavor=flavor_HVGs, subset=subset_HVGs)
    sc$pl$highly_variable_genes(adata, save='.pdf')
    move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
  }


  #scaling and PCA

  if (perform_PCA==TRUE) {

    #If hvgs have been previously computed:
    if ('HVGs' %in% names(adata$var)) {
      add_annotation_var(adata, adata$var['HVGs'], 'highly_variable')
      delete_annotation_var(adata, 'HVGs')
    }
    if (scale_data==TRUE) {
      if ('highly_variable' %in% names(adata$var)) {
        adata_PCA <- subset_anndata_genes(adata, adata$var['highly_variable']$highly_variable)
        if (perform_regression==TRUE & !is.null(regress_vars)) {
          sc$pp$regress_out(adata_PCA, regress_vars)
        }
        sc$pp$scale(adata_PCA)
        sc$tl$pca(adata_PCA, svd_solver='arpack')
        if (plot_PCA_heatmap==TRUE) {
          pca_heatmap(adata_PCA, components=as.integer(ncol(adata_PCA$obsm['X_pca'])), use_raw=NULL, layer=NULL, filename=paste0(project_dir, "/scanpy_preprocessing/pca_heatmap.pdf"))
        }

        add_annotation_var(adata, adata_PCA$var['mean'], 'mean')
        add_annotation_var(adata, adata_PCA$var['std'], 'std')
        add_uns(adata, adata_PCA$uns['pca'], 'pca')
        add_obsm(adata, adata_PCA$obsm['X_pca'], 'X_pca')
        adata_varm_PCs <- matrix(rep(as.numeric(0), length(adata$var_names$tolist())*50), ncol=50, nrow=length(adata$var_names$tolist()))
        rownames(adata_varm_PCs) <- adata$var_names$tolist()
        adata_varm_PCs[adata_PCA$var_names$tolist(),] <- adata_PCA$varm['PCs']
        add_varm(adata, adata_varm_PCs, 'PCs')
      } else {
        if (perform_regression==TRUE & !is.null(regress_vars)) {
          sc$pp$regress_out(adata, regress_vars)
        }
        sc$pp$scale(adata)
        sc$tl$pca(adata, svd_solver='arpack')
        if (plot_PCA_heatmap==TRUE) {
          pca_heatmap(adata, components=as.integer(ncol(adata$obsm['X_pca'])), use_raw=NULL, layer=NULL, filename=paste0(project_dir, "/scanpy_preprocessing/pca_heatmap.pdf"))
        }
      }
    } else {
      if ('highly_variable' %in% names(adata$var)) {
        adata_PCA <- subset_anndata_genes(adata, adata$var['highly_variable']$highly_variable)
        sc$tl$pca(adata_PCA, svd_solver='arpack')
        if (plot_PCA_heatmap==TRUE) {
          pca_heatmap(adata_PCA, components=as.integer(ncol(adata_PCA$obsm['X_pca'])), use_raw=NULL, layer=NULL, filename=paste0(project_dir, "/scanpy_preprocessing/pca_heatmap.pdf"))
        }

        add_annotation_var(adata, adata_PCA$var['mean'], 'mean')
        add_annotation_var(adata, adata_PCA$var['std'], 'std')
        add_uns(adata, adata_PCA$uns['pca'], 'pca')
        add_obsm(adata, adata_PCA$obsm['X_pca'], 'X_pca')
        adata_varm_PCs <- matrix(rep(as.numeric(0), length(adata$var_names$tolist())*50), ncol=50, nrow=length(adata$var_names$tolist()))
        rownames(adata_varm_PCs) <- adata$var_names$tolist()
        adata_varm_PCs[adata_PCA$var_names$tolist(),] <- adata_PCA$varm['PCs']
        add_varm(adata, adata_varm_PCs, 'PCs')
      } else {
        sc$tl$pca(adata, svd_solver='arpack')
        if (plot_PCA_heatmap==TRUE) {
          pca_heatmap(adata, components=as.integer(ncol(adata$obsm['X_pca'])), use_raw=NULL, layer=NULL, filename=paste0(project_dir, "/scanpy_preprocessing/pca_heatmap.pdf"))
        }
      }
    }
    sc$pl$pca_variance_ratio(adata, log=TRUE, save='.pdf')
    move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
  }

  #neighbors
  if (is.null(n_pcs)) {
    n_pcs <- ncol(adata$obsm['X_pca'])
  }

  if (compute_neighbor_graph==TRUE) {
    sc$pp$neighbors(adata, n_neighbors=as.integer(n_neighbors), n_pcs=as.integer(n_pcs))
  }

  #clustering of neighborhood graph

  if (perform_clustering==TRUE) {
    sc$tl$leiden(adata)
    add_annotation_obs(adata, as.factor(adata$obs['leiden']$leiden), 'leiden')
  }

  #UMAP

  if (perform_UMAP==TRUE) {
    sc$tl$umap(adata)
  }

  #Plot PCA and UMAP

  if (is.null(color_as) & perform_clustering==TRUE) {
    color_as <- "leiden"
  }

  if (!is.null(palette) & !is.list(palette)) {
    stop("palette is not a list")
  }

  if (!is.null(lab_order) & !is.list(lab_order)) {
    stop("lab_order is not a list")
  }

  if (perform_PCA==TRUE) {
    if (is.null(color_as)) {
      draw_embedding(adata, file_name="_gene_expression", emb='pca', legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
    } else {
      for (i in 1:length(color_as)) {
        if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("character","factor")) {
          c_type_i <- "categorical"
        } else if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("integer","numeric")) {
          c_type_i <- "numeric"
        }
        if (is.null(palette)) {
          pal_i <- NULL
        } else {
          pal_i <- palette[[i]]
        }
        if (is.null(lab_order)) {
          c_ord_i <- NULL
        } else {
          c_ord_i <- lab_order[[i]]
        }
        draw_embedding(adata, file_name=paste0("_gene_expression_", color_as[i]), emb='pca', c_as=color_as[i], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
      }
    }
  }
  move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")

  if (perform_UMAP==TRUE) {
    if (is.null(color_as)) {
      draw_embedding(adata, file_name="_gene_expression", emb='umap', legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
    } else {
      for (i in 1:length(color_as)) {
        if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("character","factor")) {
          c_type_i <- "categorical"
        } else if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("integer","numeric")) {
          c_type_i <- "numeric"
        }
        if (is.null(palette)) {
          pal_i <- NULL
        } else {
          pal_i <- palette[[i]]
        }
        if (is.null(lab_order)) {
          c_ord_i <- NULL
        } else {
          c_ord_i <- lab_order[[i]]
        }
        draw_embedding(adata, file_name=paste0("_gene_expression_", color_as[i]), emb='umap', c_as=color_as[i], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
      }
    }
  }
  move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")

  #Rename HVGs

  if ('highly_variable' %in% names(adata$var)) {
    add_annotation_var(adata, adata$var['highly_variable'], 'HVGs')
    delete_annotation_var(adata, 'highly_variable')
  }

  #Differential genes

  if (find_DEGs==TRUE) {
    if (is.null(groups_for_DEGs)) {
      if (perform_clustering==TRUE) {
        groups_for_DEGs <- "leiden"
        sc$tl$rank_genes_groups(adata, groupby=groups_for_DEGs, method=method_for_DEGs, use_raw=FALSE)
        sc$pl$rank_genes_groups(adata, n_genes=as.integer(DEGs_to_show), sharey=FALSE, save='.pdf')
        move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
      } else {
        cat("WARNING: DEGs computation skipped - no groups defined")
        cat("\n")
      }
    } else {
      sc$tl$rank_genes_groups(adata, groupby=groups_for_DEGs, method=method_for_DEGs, use_raw=FALSE)
      sc$pl$rank_genes_groups(adata, n_genes=as.integer(DEGs_to_show), sharey=FALSE, save='.pdf')
      move_plots(project_dir=project_dir, subfolder="scanpy_preprocessing")
    }
  }

  cat("Removed temporary figures directory")
  cat("\n")

  if (adata_copy == TRUE) {
    return(adata)
  }
}


#' @title compute_future_states
#'
#' @description Computes gene velocities with scVelo and infers future spliced transcriptional states by summing velocities to observed states. Velocities can be computed either from the spliced and unspliced normalized counts, or from the spliced and unspliced first order moments (default procedure of scVelo). The spliced transcriptional states will be consequently defined either as spliced normalized counts, or spliced first order moments
#'
#' @param adata anndata object with spliced and unspliced gene counts stored into the "spliced" and "unspliced" layers, respectively
#' @param min_counts minimum number of spliced counts required for a gene to be retained for velocity computation
#' @param min_cells minimum number of expressing cells (spliced counts only) required for a gene to be retained for velocity computation
#' @param max_counts maximum number of spliced counts allowed for a gene to be retained for velocity computation
#' @param max_cells maximum number of expressing cells (spliced counts only) allowed for a gene to be retained for velocity computation
#' @param min_counts_u minimum number of unspliced counts required for a gene to be retained for velocity computation
#' @param max_counts_u minimum number of expressing cells (unspliced counts only) required for a gene to be retained for velocity computation
#' @param min_cells_u maximum number of unspliced counts allowed for a gene to be retained for velocity computation
#' @param max_cells_u maximum number of expressing cells (unspliced counts only) allowed for a gene to be retained for velocity computation
#' @param min_shared_counts minimum number of spliced OR unspliced counts required for a gene to be retained for velocity computation
#' @param min_shared_cells minimum number of expressing cells (spliced OR unspliced counts) required for a gene to be retained for velocity computation
#' @param retain_genes character vector containing a list of genes to be retained for velocity computation regardless of the filters
#' @param n_pcs number of PCs to consider for the nearest neighbor graph computation (necessary for first order moments computation, skipped if use_raw=TRUE, or if the graph is already present)
#' @param n_neighbors number of nearest neighbors to compute for each cell in the nearest neighbor graph (necessary for first order moments computation, skipped if use_raw=TRUE, or if the graph is already present). Default is 30 neighbors
#' @param mode_moments method for first order moments computation. Choose between "distances" or "connectivities". Default is "connectivities"
#' @param use_raw boolean; whether to use normalized counts for velocity computation instead of first order moments. Default is FALSE
#' @param n_cores number of cores to use for dynamical model fitting. If NULL (default), only 1 will be used
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis. In both cases, velocities, first order moments (both spliced and unspliced) and future spliced transcriptional states will be saved as additional layers
#'
#' @examples
#' #Compute velocities and future spliced transcriptional states for all genes
#'
#' compute_future_states(adata)
#'
#' #Compute velocities and future spliced transcriptional states only for the genes that are expressed with at least 20 normalized spliced or unspliced counts across all cells
#'
#' compute_future_states(adata, min_shared_counts=20)
#'
#' #Compute velocities and future spliced transcriptional states for all genes using normalized counts instead of first order moments. Save results in a separate anndata object
#'
#' adata_future_states <- compute_future_states(adata, use_raw=TRUE, adata_copy=TRUE)
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

compute_future_states <- function (adata, min_counts=NULL, min_cells=NULL, max_counts=NULL, max_cells=NULL, min_counts_u=NULL, min_cells_u=NULL, max_counts_u=NULL, max_cells_u=NULL, min_shared_counts=NULL, min_shared_cells=NULL, retain_genes=NULL, n_pcs=NULL, n_neighbors=30, mode_moments='connectivities', use_raw=FALSE, n_cores=NULL, adata_copy=FALSE) {
  scv <- import("scvelo")
  if (adata_copy==TRUE) {
    adata = adata$copy()
  }

  cat("Now printing scVelo output messages...")
  cat("\n")

  gene_filters <- list(min_counts, min_cells, max_counts, max_cells, min_counts_u, min_cells_u, max_counts_u, max_cells_u, min_shared_counts, min_shared_cells)
  for (i in 1:length(gene_filters)) {
    if (!is.null(gene_filters[[i]])) {
      gene_filters[[i]] <- as.integer(gene_filters[[i]])
    }
  }

  scv$pp$filter_genes(adata, min_counts=gene_filters[[1]], min_cells=gene_filters[[2]], max_counts=gene_filters[[3]], max_cells=gene_filters[[4]], min_counts_u=gene_filters[[5]], min_cells_u=gene_filters[[6]], max_counts_u=gene_filters[[7]], max_cells_u=gene_filters[[8]], min_shared_counts=gene_filters[[9]], min_shared_cells=gene_filters[[10]], retain_genes=retain_genes)
  scv$pp$normalize_per_cell(adata)

  if (is.null(n_pcs)) {
    n_pcs <- ncol(adata$obsm['X_pca'])
  }

  if (use_raw==FALSE) {
    scv$pp$moments(adata, n_pcs=as.integer(n_pcs), n_neighbors=as.integer(n_neighbors), mode=mode_moments)
  }

  if (!is.null(n_cores)) {
    n_cores <- as.integer(n_cores)
  }
  scv$tl$recover_dynamics(adata, use_raw=use_raw, n_jobs=n_cores)
  scv$tl$velocity(adata, mode='dynamical', use_raw=use_raw)

  if (use_raw==FALSE) {
    Ms_observed <- adata$layers['Ms']

    Ms_velocity <- adata$layers['velocity']
    Ms_velocity[is.nan(Ms_velocity)] <- 0

    Ms_future <- Ms_observed + Ms_velocity

    add_layer(adata, Ms_future, "Ms_future", transpose=FALSE, compress=FALSE)
  } else {
    spliced_observed <- as.matrix(adata$layers['spliced']$todense())

    spliced_velocity <- adata$layers['velocity']
    spliced_velocity[is.nan(spliced_velocity)] <- 0

    spliced_future <- spliced_observed + spliced_velocity

    add_layer(adata, spliced_future, "spliced_future", transpose=FALSE, compress=TRUE)
  }

  if (adata_copy==TRUE) {
    return(adata)
  }
}


#' @title plot_velocity
#'
#' @description Computes the RNA velocity vector field and draws the streamplot on an embedding of choice
#'
#' @param adata anndata object containing the results of the "compute_velocity" function
#' @param project_dir name of the directory containing the results of the main FIERCE analysis (including the path). If it does not exist, it will be created. The default name is "./FIERCE_results". The streamplot will be saved in the "velocity_field_streamplots" sub-directory
#' @param sqrt_transform boolean; whether to apply the variance-stabilizing transformation during transition probabilities computation. It helps to obtain a smoother streamplot. Default is TRUE
#' @param embedding_basis name of the embedding to use for the streamplot. Default is "umap"
#' @param force_graph_recalc whether to force the recalculation of the cell-cell transition probabilities matrix, if already present. Default is FALSE
#' @param compute_latent_time whether to additionally compute and plot the latent time of each cell in the dynamical model. Default is FALSE
#' @param color_as character vector containing the names of the cell annotations in the "obs" slot to visualize on the streamplot
#' @param lab_order optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the order by which the respective labels should be printed in the legends of the streamplots. If it is not necessary to specify a particular order for a specific annotation, just write NULL. If it is not necessary to specify any order for any annotation, do not change the default value of this parameter
#' @param palette optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the colors of the respective labels. If it is not necessary to specify any color for a specific annotation, just write NULL; in this case, a default color palette will be used. If it is not necessary to specify any color for any annotation, do not change the default value of this parameter; in this case, annotations will be colored according either to a default palette, or to the colors that are already stored in the anndata object ("uns" slot)
#' @param legend_loc localization of the legend on the streamplot. Default is "right margin"
#' @param alpha transparency of the dots on the streamplots, ranging from 0 (fully transparent) to 1 (fully opaque). Default is 0.3
#' @param add_outline whether to add an outline around groups of dots on the streamplots. Default is TRUE
#' @param min_mass minimum magnitude required for velocity vectors to be drawn on the streamplot, ranging from 0 (all vectors) to 5 (most intense vectors only). Default is 4
#' @param n_cores number of cores to use to compute the cell-cell transition probability matrix (most computationally expensive step). If NULL (default), only 1 will be used
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis. In both cases, the velocity graph (correlations used for transition probabilities computation) will be saved in the "uns" slot, and the predicted displacements of cells (used for streamplot drawing) will be saved in the "obsm" slot
#'
#' @examples
#' #Draw the streamplot on the UMAP embedding. In this example, the clusters, the cell types and the cell cycle phase are visualized on the streamplot. A specific label order and a specific color for each label is specified for the cell cycle phase only
#'
#' plot_velocity(adata, color_as=c("clusters", "cell_types", "phase"), lab_order=list(NULL, NULL, c("G1","S","G2M")), palette=list(NULL, NULL, c("green", "red", "blue")))
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#'
#' @export
#'

plot_velocity <- function(adata, project_dir="./FIERCE_results", sqrt_transform=TRUE, embedding_basis='umap', force_graph_recalc=FALSE, compute_latent_time=FALSE, color_as=NULL, lab_order=NULL, palette=NULL, legend_loc='right margin', alpha=0.3, add_outline=TRUE, min_mass=4, n_cores=NULL, adata_copy=FALSE) {
  scv <- import("scvelo")

  if (check_layers(adata, "velocity")=="No") {
    stop("RNA velocity has not been computed yet, please launch compute_velocity first")
  }

  if (dir.exists(project_dir) == FALSE) {
    dir.create(project_dir)
  }
  if (dir.exists(paste0(project_dir, "/velocity_field_streamplots")) == FALSE) {
    dir.create(paste0(project_dir, "/velocity_field_streamplots"))
  }

  if (adata_copy==TRUE) {
    adata = adata$copy()
  }

  if (!is.null(palette) & !is.list(palette)) {
    stop("palette is not a list")
  }

  if (!is.null(lab_order) & !is.list(lab_order)) {
    stop("lab_order is not a list")
  }

  cat("Now printing scVelo output messages...")
  cat("\n")

  if (check_uns(adata, "velocity_graph")=="No" | force_graph_recalc==TRUE) {
    if (!is.null(n_cores)) {
      n_cores <- as.integer(n_cores)
    }
    scv$tl$velocity_graph(adata, sqrt_transform=sqrt_transform, n_jobs=n_cores)
  }

  if (compute_latent_time==TRUE) {
    scv$tl$latent_time(adata)
    color_as <- c(color_as,"latent_time")
  }

  if (is.null(color_as)) {
    draw_embedding(adata, file_name=paste0(embedding_basis, "_streamplot_RNA_velocity"), emb=embedding_basis, stream=TRUE, vkey='velocity', legend_loc=legend_loc, alpha=alpha, add_outline=add_outline, min_mass=min_mass)
  } else {
    for (i in 1:length(color_as)) {
      if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("character","factor")) {
        c_type_i <- "categorical"
      } else if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("integer","numeric")) {
        c_type_i <- "numeric"
      }
      if (is.null(palette) | color_as[i]=="latent_time") {
        pal_i <- NULL
      } else {
        pal_i <- palette[[i]]
      }
      if (is.null(lab_order) | color_as[i]=="latent_time") {
        c_ord_i <- NULL
      } else {
        c_ord_i <- lab_order[[i]]
      }
      draw_embedding(adata, file_name=paste0(embedding_basis, "_streamplot_RNA_velocity_", color_as[i]), emb=embedding_basis, stream=TRUE, c_as=color_as[i], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, vkey='velocity', legend_loc=legend_loc, alpha=alpha, add_outline=add_outline, min_mass=min_mass)
    }
  }
  move_plots(project_dir=project_dir, subfolder="velocity_field_streamplots")
  rename_plots(project_dir=project_dir, subfolder="velocity_field_streamplots")

  cat("Removed temporary figures directory")
  cat("\n")
  
  if (adata_copy==TRUE) {
    return(adata)
  }
}


#' @title compute_signaling_entropy
#'
#' @description Computes both observed and future signaling entropies from observed and future spliced transcriptional states, respectively, and then computes the velocities of the entropy by subtracting observed entropies from future entropies. Signaling entropy is computed by the SCENT package, that works on the distribution of the expression signal of cells on a genome-wide Protein-Protein Interaction (PPI) network. Spliced transcriptional states are defined either as normalized spliced counts, or as spliced first order moments, depending on the input data from which gene velocities have been previously computed (see "compute_velocity" function). WARNING: signaling entropy is very accurate, but, as a downside, requires a very long computational time, especially for particularly large datasets. To avoid losing precious data, FIERCE subdivides the dataset into smaller batches (5000 cells by default, but it can be changed through the dedicated option) and saves the results after the computations for each batch are concluded. These results are saved into a temporary python dictionary that is placed into the current working directory, and is automatically removed after all the computations have been done. DO NOT REMOVE the dictionary until then, or you'll lose all the computations. If the computations are accidentally interrupted, just re-launch the function with the same command, and FIERCE will continue the analysis from the point where it was interrupted. For large datasets, it is recommended to set "adata_copy" to FALSE (to progressively update the anndata object with new results as the analysis proceeds) and to increase the number of allocated cores through the "n_cores" function 
#'
#' @param adata anndata object generated by the "compute_velocity" function, and containing either the "spliced" and "spliced_future" layers, or the "Ms" and "Ms_future" layers
#' @param use_raw boolean; whether gene velocities have been computed from the normalized counts instead of the first order moments (see documentation for "compute_velocity" function). This will affect the layer from which entropies will be computed. Default is FALSE
#' @param log_transform_input_matrix boolean; whether to log-transform the input matrices before entropy computation. Default is TRUE
#' @param use_original_SCENT_network boolean; whether to use the original PPI network included in the SCENT package (human entrez ids only). If FALSE, one of the FIERCE built-in networks will be used. Default is FALSE
#' @param most_recent_network boolean; if use_original_SCENT_network=TRUE, use the most recent version of the PPI network. Default is TRUE
#' @param use_builtin_network boolean; whether to use one of the FIERCE built-in PPI networks. If FALSE (and use_original_SCENT_network=FALSE), the user must manually provide their own network. Default is TRUE
#' @param species only used if use_builtin_network=TRUE; choose between "Human" and "Mouse"
#' @param network_nomenclature only used if use_builtin_network=TRUE; gene nomenclature to use in the PPI network. Choose between "gene_symbol" or "entrez"
#' @param network_threshold only used if use_builtin_network=TRUE; minimum level of confidence required for the edges (i.e., the protein-protein interactions) of the PPI network. Choose between "medium" and "high". Default is "high"
#' @param user_network only used if use_builtin_network=FALSE and use_original_SCENT_network=FALSE; PPI network provided by the user. It must be a binary numeric matrix with gene names on both the rows and the columns, where 1 stands for "interaction" and 0 stands for "no interaction". The nomenclature of the genes must correspond to the nomenclature of the genes of the anndata object
#' @param n_cores number of cores to use for entropy computation. Default is 1. Parallel computing option is provided (and recommended) as this is the most time-consuming step of the FIERCE pipeline
#' @param batch_size number of cells in each batch for entropy computation
#' @param compute_potency_states boolean; whether to compute observed and future potency states by combining the distribution of total entropies with a pre-computed phenotype annotation. Default is FALSE
#' @param phenotype_annotation only used if compute_potency_states=TRUE; name of the cell annotation in the "obs" slot to combine with the distribution of total entropies for potency states computation
#' @param potency_states_only_mode if this mode is "on", only the potency states are computed from pre-existing entropy scores that are already stored in the anndata object. Very useful if the user wishes to try different phenotype annotations for potency states computation. Default is "off", change to "on" to activate
#' @param extensive_output if TRUE, include the complete output of the SCENT algorithm (including data that are not necessary for velocity of the entropy computation; for more info, please see the SCENT documentation). Default is FALSE to save space
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis. In both cases, the matrix of the velocities of the entropy and the matrices of the partial entropies (both observed and future) will be saved as additional layers
#'
#' @examples
#' #Run SCENT with the FIERCE built-in human gene symbol PPI network (high confidence). Infer potency states from total entropies and pre-computed cell clusters. Use parallel computing with 20 cores
#'
#' compute_signaling_entropy(adata, use_builtin_network=TRUE, species="Human", network_nomenclature="gene_symbol", network_threshold="high", compute_potency_states=TRUE, phenotype_annotation="clusters", n_cores=20)
#'
#' #Run SCENT on normalized spliced counts (instead of spliced first order moments) with a user provided PPI network. Do not compute potency states. Use parallel computing with 20 cores
#'
#' compute_signaling_entropy(adata, use_raw=TRUE, use_builtin_network=FALSE, user_network=PPI_network, compute_potency_states=FALSE, n_cores=20)
#'
#' #Run function in potency_states_only_mode, i.e., only the potency states will be computed from pre-existing entropy scores that are already stored in the anndata object. The results are saved in a new anndata object
#'
#' adata_potency_states <- compute_signaling_entropy(adata, phenotype_annotation="clusters", potency_states_only_mode="on", adata_copy=TRUE)
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#' @export
#'

compute_signaling_entropy <- function(adata, use_raw=FALSE, log_transform_input_matrix=TRUE, use_original_SCENT_network=FALSE, most_recent_network=TRUE, use_builtin_network=TRUE, species="Human", network_nomenclature="gene_symbol", network_threshold="high", user_network=NULL, n_cores=1, batch_size=5000, compute_potency_states=FALSE, phenotype_annotation=NULL, potency_states_only_mode="off", debug_mode=FALSE, extensive_output=FALSE, adata_copy=FALSE) {
  if (is.null(adata)) {
    stop("Please provide an anndata object")
  }
  shelve <- import("shelve")
  if (adata_copy==TRUE) {
    adata <- adata$copy()
  } else {
    h <- deparse(substitute(adata))
  }
  if ((length(adata$obs_names$tolist())>batch_size) & (potency_states_only_mode=="off")) {
    if (length(grep("temp_shelf", dir()))>0) {
      shelf <- shelve$open("temp_shelf", writeback=TRUE)
    } else {
      shelf <- shelve$open("temp_shelf",'n', writeback=TRUE)
    }
  }

  if (potency_states_only_mode=="off") {

  if (check_layers(adata, "SCENT_input_matrix_observed")=="No") {

    cat("Creating input matrix from observed transcriptional states...")
    cat("\n")

    if (use_raw==FALSE) {
      input_matrix_obs <- adata$layers['Ms']
    } else {
      input_matrix_obs <- as.matrix(adata$layers['spliced']$todense())
    }

    input_matrix_obs <- t(input_matrix_obs)
    rownames(input_matrix_obs) <- adata$var_names$tolist()
    colnames(input_matrix_obs) <- adata$obs_names$tolist()

    if (log_transform_input_matrix==TRUE) {
      input_matrix_obs <- log2(input_matrix_obs+1.1)
    } else {
      input_matrix_obs <- input_matrix_obs+0.1
    }

    add_layer(adata, input_matrix_obs, "SCENT_input_matrix_observed", transpose=TRUE, compress=FALSE)

  } else {
    cat("Observed input matrix already computed")
    cat("\n")
  }

  if (check_layers(adata, "SCENT_input_matrix_future")=="No") {

    cat("Creating input matrix from future transcriptional states...")
    cat("\n")

    if (use_raw==FALSE) {
      input_matrix_fut <- adata$layers['Ms_future']
    } else {
      input_matrix_fut <- as.matrix(adata$layers['spliced_future']$todense())
    }

    input_matrix_fut <- t(input_matrix_fut)
    rownames(input_matrix_fut) <- adata$var_names$tolist()
    colnames(input_matrix_fut) <- adata$obs_names$tolist()

    if (log_transform_input_matrix==TRUE) {
      input_matrix_fut <- log2(input_matrix_fut+1.1)
    } else {
      input_matrix_fut <- input_matrix_fut+0.1
    }

    add_layer(adata, input_matrix_fut, "SCENT_input_matrix_future", transpose=TRUE, compress=FALSE)

  } else {
    cat("Future input matrix already computed")
    cat("\n")
  }

  # Load PPI network
  cat("Loading PPI network...")
  cat("\n")
  if (use_original_SCENT_network == TRUE) {
    if (most_recent_network == TRUE) {
      data(net17Jan16)
      network <- net17Jan16.m
    } else {
      data(net13Jun12)
      network <- net13Jun12.m
    }
  } else if (use_builtin_network == TRUE) {
    if (species=="Human") {
      if (network_nomenclature=="gene_symbol"){
        if (network_threshold=="high"){
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_sym_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_high_sym_pruned
        } else if (network_threshold=="medium") {
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_sym_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_medium_sym_pruned
        } else {
          stop("Choose either medium or high for network threshold")
        }
      } else if (network_nomenclature=="entrez") {
        if (network_threshold=="high"){
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_", network_nomenclature, "_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_high_entrez_pruned
        } else if (network_threshold=="medium") {
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_", network_nomenclature, "_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_medium_entrez_pruned
        } else {
          stop("Choose either medium or high for network threshold")
        }
      } else {
        stop("Only entrez or gene symbols available for network")
      }
    } else if (species=="Mouse") {
      if (network_nomenclature=="gene_symbol"){
        if (network_threshold=="high"){
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_sym_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_high_sym_pruned
        } else if (network_threshold=="medium") {
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_sym_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_medium_sym_pruned
        } else {
          stop("Choose either medium or high for network threshold")
        }
      } else if (network_nomenclature=="entrez") {
        if (network_threshold=="high"){
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_", network_nomenclature, "_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_high_entrez_pruned
        } else if (network_threshold=="medium") {
          ppi_net <- system.file("STRING_networks", species, paste0("network_", network_threshold, "_", network_nomenclature, "_pruned.RData"), package = "FIERCE")
          load(ppi_net)
          network <- network_medium_entrez_pruned
        } else {
          stop("Choose either medium or high for network threshold")
        }
      } else {
        stop("Only entrez or gene symbols available for network")
      }
    } else {
      stop("Only human or mouse network available")
    }
  } else {
    if (is.null(user_network)) {
      stop("No network provided by user")
    }
    network <- user_network
  }

  if (debug_mode==TRUE) {
    print(ppi_net)
    return(network)
  }

  ####################
  ##### Observed #####
  ####################

  if (check_layers(adata, "SCENT_integrated_matrix_observed")=="No") {
  cat("Integrating observed input matrix with PPI network...")
  cat("\n")
  if (!exists("input_matrix_obs")) {
    input_matrix_obs <- t(adata$layers['SCENT_input_matrix_observed'])
    rownames(input_matrix_obs) <- adata$var_names$tolist()
    colnames(input_matrix_obs) <- adata$obs_names$tolist()
  }
  integ.l.obs <- DoIntegPPI(exp.m = input_matrix_obs, ppiA.m = network)
  adata <- subset_anndata_genes(adata, rownames(integ.l.obs$expMC), adata_copy=FALSE)
  add_layer(adata, integ.l.obs$expMC, "SCENT_integrated_matrix_observed", transpose=TRUE, compress=FALSE)
  add_uns(adata, integ.l.obs$adjMC, "SCENT_maximally_connected_subnetwork_observed", nested=FALSE, sub_slot=NULL)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat(paste0(as.character(length(rownames(integ.l.obs$expMC))), " genes remaining after integration of observed input matrix with PPI network"))
  cat("\n")
  } else {
    cat("Integrated observed matrix already computed")
    cat("\n")
  }

  if (!("total_entropies_observed" %in% names(adata$obs))) {
  # compute the entropy
  cat("Computing observed entropies (this could take a while)...")
  cat("\n")
  if (!exists("integ.l.obs")) {
    expMC <- t(adata$layers['SCENT_integrated_matrix_observed'])
    rownames(expMC) <- adata$var_names$tolist()
    colnames(expMC) <- adata$obs_names$tolist()
    adjMC <- adata$uns['SCENT_maximally_connected_subnetwork_observed']
    rownames(adjMC) <- adata$var_names$tolist()
    colnames(adjMC) <- adata$var_names$tolist()
    integ.l.obs <- list(expMC=expMC, adjMC=adjMC)
  }
  if (length(adata$obs_names$tolist())<=batch_size) {
  sr.o.obs <- CompSRana(integ.l.obs, local = TRUE, mc.cores = n_cores)
  add_annotation_obs(adata, sr.o.obs$SR, "total_entropies_observed")
  if (extensive_output==TRUE) {
    add_layer(adata, sr.o.obs$inv, "invariant_measure_observed", transpose=TRUE, compress=FALSE)
    add_layer(adata, sr.o.obs$locS, "partial_entropies_observed_unnormalized", transpose=TRUE, compress=FALSE)
  }
  add_layer(adata, sr.o.obs$nlocS, "partial_entropies_observed", transpose=TRUE, compress=FALSE)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat("Done!")
  cat("\n")
  } else {
  sequence <- c(seq(0, length(adata$obs_names$tolist()), by=batch_size), length(adata$obs_names$tolist()))
  for (i in 2:length(sequence)) {
    if (key_in_shelf(shelf, "partial_entropies_observed")=="yes") {
      if (ncol(shelf['partial_entropies_observed'])>=sequence[i]) next
    }
    integ.l.obs.i <- integ.l.obs
    if ((sequence[i+1]-sequence[i])>100) {
    cat(paste0("Parsing cells from ", as.character(sequence[i-1]+1), " to ", as.character(sequence[i]), "..."))
    cat("\n")
    integ.l.obs.i$expMC <- integ.l.obs.i$expMC[,(sequence[i-1]+1):sequence[i]]
    } else {
    cat(paste0("Parsing cells from ", as.character(sequence[i-1]+1), " to ", as.character(sequence[i+1]), "..."))
    cat("\n")
    integ.l.obs.i$expMC <- integ.l.obs.i$expMC[,(sequence[i-1]+1):sequence[i+1]]  
    }
    sr.o.obs <- CompSRana(integ.l.obs.i, local = TRUE, mc.cores = n_cores)
    if (is.null(ncol(sr.o.obs$nlocS))) {
      stop("SCENT algorithm has run out of memory, please re-launch the command with less cores")
    }
    if (key_in_shelf(shelf, "partial_entropies_observed")=="yes") {
      add_shelves(shelf, "total_entropies_observed", c(shelf['total_entropies_observed'], sr.o.obs$SR))
      if (extensive_output==TRUE) {
        add_shelves(shelf, "invariant_measure_observed", cbind(shelf['invariant_measure_observed'], sr.o.obs$inv))
        add_shelves(shelf, "partial_entropies_observed_unnormalized", cbind(shelf['partial_entropies_observed_unnormalized'], sr.o.obs$locS))
      }
      add_shelves(shelf, "partial_entropies_observed", cbind(shelf['partial_entropies_observed'], sr.o.obs$nlocS))
    } else {
      add_shelves(shelf, "total_entropies_observed", sr.o.obs$SR)
      if (extensive_output==TRUE) {
        add_shelves(shelf, "invariant_measure_observed", sr.o.obs$inv)
        add_shelves(shelf, "partial_entropies_observed_unnormalized", sr.o.obs$locS)
      }
      add_shelves(shelf, "partial_entropies_observed", sr.o.obs$nlocS)
    }
    shelf$sync()
  }
  add_annotation_obs(adata, shelf["total_entropies_observed"], "total_entropies_observed")
  if (extensive_output==TRUE) {
  add_layer(adata, shelf["invariant_measure_observed"], "invariant_measure_observed", transpose=TRUE, compress=FALSE)
  add_layer(adata, shelf["partial_entropies_observed_unnormalized"], "partial_entropies_observed_unnormalized", transpose=TRUE, compress=FALSE)
  }
  add_layer(adata, shelf["partial_entropies_observed"], "partial_entropies_observed", transpose=TRUE, compress=FALSE)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat("Done!")
  cat("\n")
  }
  } else {
    cat("Observed signaling entropies already computed")
    cat("\n")
  }

  ##Inference of potency states in the population ####
  if ((compute_potency_states==TRUE) & !("Potency_states_observed" %in% names(adata$obs))) {
    cat("Computing observed potency states...")
    cat("\n")
    sr.v<-adata$obs['total_entropies_observed'][,'total_entropies_observed']
    if (is.null(phenotype_annotation)) {
      stop("Missing phenotypes for potency states computation")
    }
    pot.o.obs <- InferPotencyStates(potest.v=sr.v, pheno.v = adata$obs[phenotype_annotation][,phenotype_annotation])
    add_annotation_obs(adata, as.character(pot.o.obs$potS), "Potency_states_observed")
    add_uns(adata, pot.o.obs$distr, "Potency_states_distribution_observed", nested=FALSE, sub_slot=NULL)
    add_uns(adata, pot.o.obs$prob, "Potency_states_probabilities_observed", nested=FALSE, sub_slot=NULL)
    add_uns(adata, pot.o.obs$het, "Phenotypes_entropy_heterogeneity_observed", nested=FALSE, sub_slot=NULL)
    if(adata_copy==FALSE) {
      assign(h, adata, envir=.GlobalEnv)
    }
  } else if ((compute_potency_states==TRUE) & ("Potency_states_observed" %in% names(adata$obs))) {
    cat("Observed potency states already computed")
    cat("\n")
  }

  ##################
  ##### Future #####
  ##################

  if (check_layers(adata, "SCENT_integrated_matrix_future")=="No") {
  cat("Integrating future input matrix with PPI network...")
  cat("\n")
  if (!exists("input_matrix_fut")) {
    input_matrix_fut <- t(adata$layers['SCENT_input_matrix_future'])
    rownames(input_matrix_fut) <- adata$var_names$tolist()
    colnames(input_matrix_fut) <- adata$obs_names$tolist()
  }
  integ.l.fut <- DoIntegPPI(exp.m = input_matrix_fut, ppiA.m = network)
  add_layer(adata, integ.l.fut$expMC, "SCENT_integrated_matrix_future", transpose=TRUE, compress=FALSE)
  add_uns(adata, integ.l.fut$adjMC, "SCENT_maximally_connected_subnetwork_future", nested=FALSE, sub_slot=NULL)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat(paste0(as.character(length(rownames(integ.l.obs$expMC))), " genes remaining after integration of future input matrix with PPI network"))
  cat("\n")
  } else {
    cat("Integrated future matrix already computed")
    cat("\n")
  }

  if (!("total_entropies_future" %in% names(adata$obs))) {
  # compute the entropy
  cat("Computing future entropies (this could take a while)...")
  cat("\n")
  if (!exists("integ.l.fut")) {
    expMC <- t(adata$layers['SCENT_integrated_matrix_future'])
    rownames(expMC) <- adata$var_names$tolist()
    colnames(expMC) <- adata$obs_names$tolist()
    adjMC <- adata$uns['SCENT_maximally_connected_subnetwork_future']
    rownames(adjMC) <- adata$var_names$tolist()
    colnames(adjMC) <- adata$var_names$tolist()
    integ.l.fut <- list(expMC=expMC, adjMC=adjMC)
  }
  if (length(adata$obs_names$tolist())<=batch_size) {
  sr.o.fut <- CompSRana(integ.l.fut, local = TRUE, mc.cores = n_cores)
  add_annotation_obs(adata, sr.o.fut$SR, "total_entropies_future")
  if (extensive_output==TRUE) {
  add_layer(adata, sr.o.fut$inv, "invariant_measure_future", transpose=TRUE, compress=FALSE)
  add_layer(adata, sr.o.fut$locS, "partial_entropies_future_unnormalized", transpose=TRUE, compress=FALSE)
  }
  add_layer(adata, sr.o.fut$nlocS, "partial_entropies_future", transpose=TRUE, compress=FALSE)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat("Done!")
  cat("\n")
  } else {
  sequence <- c(seq(0, length(adata$obs_names$tolist()), by=batch_size), length(adata$obs_names$tolist()))
  for (i in 2:length(sequence)) {
    if (key_in_shelf(shelf, "partial_entropies_future")=="yes") {
      if (ncol(shelf['partial_entropies_future'])>=sequence[i]) next
    }
    integ.l.fut.i <- integ.l.fut
    if ((sequence[i+1]-sequence[i])>100) {
    cat(paste0("Parsing cells from ", as.character(sequence[i-1]+1), " to ", as.character(sequence[i]), "..."))
    cat("\n")
    integ.l.fut.i$expMC <- integ.l.fut.i$expMC[,(sequence[i-1]+1):sequence[i]]
    } else {
    cat(paste0("Parsing cells from ", as.character(sequence[i-1]+1), " to ", as.character(sequence[i+1]), "..."))
    cat("\n")
    integ.l.fut.i$expMC <- integ.l.fut.i$expMC[,(sequence[i-1]+1):sequence[i+1]]
    }
    sr.o.fut <- CompSRana(integ.l.fut.i, local = TRUE, mc.cores = n_cores)
    if (is.null(ncol(sr.o.fut$nlocS))) {
      stop("SCENT algorithm has run out of memory, please re-launch the command with less cores")
    }
    if (key_in_shelf(shelf, "partial_entropies_future")=="yes") {
      add_shelves(shelf, "total_entropies_future", c(shelf['total_entropies_future'], sr.o.fut$SR))
      if (extensive_output==TRUE) {
      add_shelves(shelf, "invariant_measure_future", cbind(shelf['invariant_measure_future'], sr.o.fut$inv))
      add_shelves(shelf, "partial_entropies_future_unnormalized", cbind(shelf['partial_entropies_future_unnormalized'], sr.o.fut$locS))
      }
      add_shelves(shelf, "partial_entropies_future", cbind(shelf['partial_entropies_future'], sr.o.fut$nlocS))
    } else {
      add_shelves(shelf, "total_entropies_future", sr.o.fut$SR)
      if (extensive_output==TRUE) {
      add_shelves(shelf, "invariant_measure_future", sr.o.fut$inv)
      add_shelves(shelf, "partial_entropies_future_unnormalized", sr.o.fut$locS)
      }
      add_shelves(shelf, "partial_entropies_future", sr.o.fut$nlocS)
    }
    shelf$sync()
  }
  add_annotation_obs(adata, shelf["total_entropies_future"], "total_entropies_future")
  if (extensive_output==TRUE) {
  add_layer(adata, shelf["invariant_measure_future"], "invariant_measure_future", transpose=TRUE, compress=FALSE)
  add_layer(adata, shelf["partial_entropies_future_unnormalized"], "partial_entropies_future_unnormalized", transpose=TRUE, compress=FALSE)
  }
  add_layer(adata, shelf["partial_entropies_future"], "partial_entropies_future", transpose=TRUE, compress=FALSE)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat("Done!")
  cat("\n")
  }
  } else {
    cat("Future signaling entropies already computed")
    cat("\n")
  }

  ##Inference of potency states in the population ####
  if ((compute_potency_states==TRUE) & !("Potency_states_future" %in% names(adata$obs))) {
    cat("Computing future potency states...")
    cat("\n")
    sr.v<-adata$obs['total_entropies_future'][,'total_entropies_future']
    if (is.null(phenotype_annotation)) {
      stop("Missing phenotypes for potency states computation")
    }
    pot.o.fut <- InferPotencyStates(potest.v=sr.v, pheno.v = adata$obs[phenotype_annotation][,phenotype_annotation])
    add_annotation_obs(adata, as.character(pot.o.fut$potS), "Potency_states_future")
    add_uns(adata, pot.o.fut$distr, "Potency_states_distribution_future", nested=FALSE, sub_slot=NULL)
    add_uns(adata, pot.o.fut$prob, "Potency_states_probabilities_future", nested=FALSE, sub_slot=NULL)
    add_uns(adata, pot.o.fut$het, "Phenotypes_entropy_heterogeneity_future", nested=FALSE, sub_slot=NULL)
    if(adata_copy==FALSE) {
      assign(h, adata, envir=.GlobalEnv)
    }
  } else if ((compute_potency_states==TRUE) & ("Potency_states_future" %in% names(adata$obs))) {
    cat("Future potency states already computed")
    cat("\n")
  }

  #################################
  #### Velocity of the entropy ####
  #################################

  if (check_layers(adata, "velocity_of_the_entropy")=="No") {
  cat("Computing velocity of the entropy...")
  cat("\n")
  velent <- adata$layers['partial_entropies_future'] - adata$layers['partial_entropies_observed']
  add_layer(adata, velent, "velocity_of_the_entropy", transpose=FALSE, compress=FALSE)
  if(adata_copy==FALSE) {
    assign(h, adata, envir=.GlobalEnv)
  }
  cat("Done!")
  cat("\n")
  } else {
    cat("Velocity of the entropy already computed")
    cat("\n")
  }

  } else if (potency_states_only_mode=="on") {

  if (!("total_entropies_observed" %in% names(adata$obs))) {
    stop("No pre-computed entropy scores in anndata object")
  }
  cat("Computing observed potency states...")
  cat("\n")
  sr.v<-adata$obs['total_entropies_observed'][,'total_entropies_observed']
  if (is.null(phenotype_annotation)) {
    stop("Missing phenotypes for potency states computation")
  }
  pot.o.obs <- InferPotencyStates(potest.v=sr.v, pheno.v = adata$obs[phenotype_annotation][,phenotype_annotation])
  cat("Done!")
  cat("\n")

  cat("Computing future potency states...")
  cat("\n")
  sr.v<-adata$obs['total_entropies_future'][,'total_entropies_future']
  if (is.null(phenotype_annotation)) {
    stop("Missing phenotypes for potency states computation")
  }
  pot.o.fut <- InferPotencyStates(potest.v=sr.v, pheno.v = adata$obs[phenotype_annotation][,phenotype_annotation])
  cat("Done!")
  cat("\n")

  add_annotation_obs(adata, as.character(pot.o.obs$potS), "Potency_states_observed")
  add_annotation_obs(adata, as.character(pot.o.fut$potS), "Potency_states_future")
  add_uns(adata, pot.o.obs$distr, "Potency_states_distribution_observed", nested=FALSE, sub_slot=NULL)
  add_uns(adata, pot.o.fut$distr, "Potency_states_distribution_future", nested=FALSE, sub_slot=NULL)
  add_uns(adata, pot.o.obs$prob, "Potency_states_probabilities_observed", nested=FALSE, sub_slot=NULL)
  add_uns(adata, pot.o.fut$prob, "Potency_states_probabilities_future", nested=FALSE, sub_slot=NULL)
  add_uns(adata, pot.o.obs$het, "Phenotypes_entropy_heterogeneity_observed", nested=FALSE, sub_slot=NULL)
  add_uns(adata, pot.o.fut$het, "Phenotypes_entropy_heterogeneity_future", nested=FALSE, sub_slot=NULL)
  }

  if (exists("shelf")) {
    shelf$close()
    cat("Removing temporary python dictionary...")
    cat("\n")
#    unlink(dir()[grep("temp_shelf", dir())])
  }

  if (adata_copy==TRUE) {
    return(adata)
  }
}

#' @title plot_entropy_results
#'
#' @description Plots the results of "compute_signaling_entropy". Saves several plots that allow a visual check of the results of the SCENT analysis, namely: a boxplot of total entropies per phenotype label (for one or more phenitype annotations chosen by the user), a boxplot of the total number of expressed genes per phenotype, a boxplot of the mean expression level per phenotype, a boxplot of the median expression level per phenotype, a scatterplot of total entropies VS total number of expressed genes, a scatterplot of total entropies VS mean expression level, a scatterplot of total entropies VS median expression level, and a dotplot of the abundancies of potency states within each phenotype label. An ANOVA test is performed for each phenotype annotation used for the boxplots. Pearson correlations between total entropies, total number of expressed genes, mean and median gene expression are also computed and printed on screen
#'
#' @param adata anndata object containing the results of "compute_signaling_entropy"
#' @param project_dir name of the directory containing the results of the main FIERCE analysis (including the path). If it does not exist, it will be created. The default name is "./FIERCE_results". The plots will be saved in the "signaling_entropy_plots" sub-directory
#' @param phenotype_annotation character vector containing the names of the cell annotations in the "obs" slot to visualize on the boxplot of the total entropies and on the dotplot of the potency states. Any number of columns can be specified
#' @param phenotype_order optional; list containing, for each phenotype annotation specified in phenotype_annotation, a character vector specifying the order by which the respective phenotype labels should be plotted. If it is not necessary to specify a particular order for a specific annotation, just write NULL. If it is not necessary to specify any order for any annotation, do not change the default value of this parameter
#' @param phenotype_colors optional; list containing, for each phenotype annotation specified in phenotype_annotation, a character vector specifying the colors for the respective phenotype labels. If it is not necessary to specify any color for a specific annotation, just write NULL; in this case, a default color palette will be used. If it is not necessary to specify any color for any annotation, do not change the default value of this parameter; in this case, annotations will be colored according either to a default palette, or to the colors that are already stored in the anndata object ("uns" slot)
#' @param horizontal whether to plot cell annotations on the horizontal axis on the boxplots. FALSE by default
#'
#' @return No objects are returned, the plots will be saved in the directory containing the results of the main FIERCE analysis ("signaling_entropy_plots" sub-directory)
#'
#' @examples
#' In this example, the clusters, the cell types and the cell cycle phase are chosen as phenotype annotations. A specific label order and a specific color for each label are specified for the cell cycle phase only
#'
#' plot_entropy_results(adata, phenotype_annotation=c("clusters", "cell_types", "phase"), phenotype_order=list(NULL, NULL, c("G1","S","G2M")), phenotype_colors=list(NULL, NULL, c("green", "red", "blue")))
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#' @export
#'

plot_entropy_results <- function(adata, project_dir="./FIERCE_results", phenotype_annotation=NULL, phenotype_order=NULL, phenotype_colors=NULL, horizontal=FALSE) {

  if (dir.exists(project_dir)==FALSE) {
    dir.create(project_dir)
  }

  if (dir.exists(paste0(project_dir, "/signaling_entropy_plots"))==FALSE) {
    dir.create(paste0(project_dir, "/signaling_entropy_plots"))
  }

  if (is.null(phenotype_annotation)) {
    stop("Missing phenotype annotation")
  }
  if (!is.null(phenotype_order) & !is.list(phenotype_order)) {
    stop("phenotype_order is not a list")
  }
  if (!is.null(phenotype_colors) & !is.list(phenotype_colors)) {
    stop("phenotype_colors is not a list")
  }

  pheno.v <- list()
  counter <- 1
  for (i in phenotype_annotation) {
    if (class(adata$obs[i][,i]) == "factor") {
      pheno.v[[counter]] <- adata$obs[i][,i]
    } else {
      pheno.v[[counter]] <- factor(adata$obs[i][,i])
    }
    if (!is.null(phenotype_order) & !is.null(phenotype_order[[counter]])) {
      for (j in phenotype_order[[counter]]) {
        pheno.v[[counter]] <- relevel(pheno.v[[counter]], ref=j)
      }
    } else {
      for (j in levels(pheno.v[[counter]])) {
        pheno.v[[counter]] <- relevel(pheno.v[[counter]], ref=j)
      }
    }
    counter <- counter+1
  }

  my_palette_extended<-c("#2171b5","#6baed6","#c6dbef","#cb181d","yellow","#fcbba1","orange","#74c476","#c7e9c0","#525252","#969696","#d9d9d9", "#762a83","#9970ab","#c2a5cf","#e7d4e8","#d9f0d3","#a6dba0","#5aae61","#1b7837","#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f","#7f2704")
  if (is.null(phenotype_colors)) {
    phenotype_colors <- list()
    for (i in 1:length(pheno.v)) {
      if (check_uns(adata,paste0(phenotype_annotation[i], "_colors"))=="No") {
        phenotype_colors[[i]] <- my_palette_extended[1:length(names(table(pheno.v[[i]])))]
      } else {
        stored_colors <- adata$uns[paste0(phenotype_annotation[i], "_colors")]
        names(stored_colors) <- names(table(adata$obs[phenotype_annotation[i]][,phenotype_annotation[i]]))
        stored_colors2 <- NULL
        for (j in names(table(pheno.v[[i]]))) {
          stored_colors2 <- c(stored_colors2, stored_colors[names(stored_colors)==j])
        }
        phenotype_colors[[i]] <- stored_colors2
      }
    }
  } else {
    for (i in 1:length(phenotype_colors)) {
      if (is.null(phenotype_colors[[i]])) {
        if (check_uns(adata,paste0(phenotype_annotation[i], "_colors"))=="No") {
          phenotype_colors[[i]] <- my_palette_extended[1:length(names(table(pheno.v[[i]])))]
        } else {
          stored_colors <- adata$uns[paste0(phenotype_annotation[i], "_colors")]
          names(stored_colors) <- names(table(adata$obs[phenotype_annotation[i]][,phenotype_annotation[i]]))
          stored_colors2 <- NULL
          for (j in names(table(pheno.v[[i]]))) {
            stored_colors2 <- c(stored_colors2, stored_colors[names(stored_colors)==j])
          }
          phenotype_colors[[i]] <- stored_colors2
        }
      } else {
          phenotype_colors[[i]] <- rev(phenotype_colors[[i]])
      }
    }
  }

  # boxplot of SR values VS phenotypic labels of interest
  cat("Boxplot entropy vs phenotype labels...")
  cat("\n")
  sr.v.obs <- adata$obs['total_entropies_observed'][,'total_entropies_observed']
  sr.v.fut <- adata$obs['total_entropies_future'][,'total_entropies_future']

  pdf(paste0(project_dir, "/signaling_entropy_plots/Boxplot_entropy_per_phenotype.pdf"), useDingbats=FALSE)
  if (horizontal==FALSE) {
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = observed_entropies, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    coord_flip() +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Observed total signaling entropy") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
    df_i <- data.frame(future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = future_entropies, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    coord_flip() +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Future total signaling entropy") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  } else {
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = observed_entropies, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    scale_x_discrete(limits = rev(levels(df_i$phenotypes))) +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Observed total signaling entropy") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), axis.text.x = element_text(angle = 45, hjust=1)))
    df_i <- data.frame(future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = future_entropies, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    scale_x_discrete(limits = rev(levels(df_i$phenotypes))) +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Future total signaling entropy") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), axis.text.x = element_text(angle = 45, hjust=1)))
  }
  }
  dev.off()

  cat("ANOVA observed entropies vs phenotype labels...")
  cat("\n")
  for (i in 1:length(pheno.v)) {
    cat(phenotype_annotation[i])
    cat("\n")
    df_i <- data.frame(observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(summary(aov(observed_entropies ~ phenotypes, data=df_i)))
    cat("\n")
  }

  cat("ANOVA future entropies vs phenotype labels...")
  cat("\n")
  for (i in 1:length(pheno.v)) {
    cat(phenotype_annotation[i])
    cat("\n")
    df_i <- data.frame(future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(summary(aov(future_entropies ~ phenotypes, data=df_i)))
    cat("\n")
  }

  # boxplot of expressed genes (ONLY genes used by SCENT) VS phenotypic labels of interest
  expression_matrix <- t(as.matrix(adata$X$todense()))
  expr.v <- apply(expression_matrix, 2, function(x) sum(x>0)) #count all genes with expr > 0 per cell

  cat("Boxplot expressed genes vs phenotype labels...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Boxplot_expressed_genes_per_phenotype.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(expressed_genes=expr.v, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = expressed_genes, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    coord_flip() +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Number of expressed genes") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  # boxplot with the mean expression computed on expressed genes for each cell
  mean.expr.v<-apply(expression_matrix, 2, function(x) mean(x[x>0]))
  cat("Boxplot mean expression vs phenotype labels...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Boxplot_mean_expression_per_phenotype.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(mean_expression=mean.expr.v, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = mean_expression, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    coord_flip() +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Mean gene expression") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  # boxplot with the median expression computed on expressed genes for each cell
  median.expr.v<-apply(expression_matrix, 2, function(x) median(x[x>0]))
  cat("Boxplot median expression vs phenotype labels...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Boxplot_median_expression_per_phenotype.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(median_expression=median.expr.v, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = phenotypes, y = median_expression, fill = phenotypes)) +
    geom_boxplot(show.legend = FALSE) +
    coord_flip() +
    scale_fill_manual(values=phenotype_colors[[i]]) +
    xlab(phenotype_annotation[i]) +
    ylab("Median gene expression") +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  # scatterplot of expressed genes VS SR value
  cat("Scatterplot expressed genes vs entropy...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Scatterplot_expressed_genes_entropy.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(expressed_genes=expr.v, observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = expressed_genes, y = observed_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Number of expressed genes") +
    ylab("Observed total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
    df_i <- data.frame(expressed_genes=expr.v, future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = expressed_genes, y = future_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Number of expressed genes") +
    ylab("Future total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  cat("Scatterplot mean expression vs entropy...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Scatterplot_mean_expression_entropy.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(mean_expression=mean.expr.v, observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = mean_expression, y = observed_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Mean gene expression") +
    ylab("Observed total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
    df_i <- data.frame(mean_expression=mean.expr.v, future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = mean_expression, y = future_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Mean gene expression") +
    ylab("Future total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  cat("Scatterplot median expression vs entropy...")
  cat("\n")
  pdf(paste0(project_dir, "/signaling_entropy_plots/Scatterplot_median_expression_entropy.pdf"), useDingbats=FALSE)
  for (i in 1:length(pheno.v)) {
    df_i <- data.frame(median_expression=median.expr.v, observed_entropies=sr.v.obs, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = median_expression, y = observed_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Median gene expression") +
    ylab("Observed total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
    df_i <- data.frame(median_expression=median.expr.v, future_entropies=sr.v.fut, phenotypes=pheno.v[[i]])
    print(ggplot(df_i, aes(x = median_expression, y = future_entropies, color = phenotypes)) +
    geom_point() +
    scale_color_manual(values=phenotype_colors[[i]]) +
    xlab("Median gene expression") +
    ylab("Future total signaling entropy") +
    guides(color = guide_legend(reverse=TRUE)) +
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black")))
  }
  dev.off()

  cat("Computing correlations...")
  cat("\n")

  # compute the correlation between SR score and expressed genes
  cat(paste0("Correlation between observed entropy score and number of expressed genes: ", as.character(cor(sr.v.obs, expr.v))))
  cat("\n")
  cat(paste0("Correlation between future entropy score and number of expressed genes: ", as.character(cor(sr.v.fut, expr.v))))
  cat("\n")
  # compute the correlation between SR score and mean of expressed genes
  cat(paste0("Correlation between observed entropy score and mean expression: ", as.character(cor(sr.v.obs, mean.expr.v))))
  cat("\n")
  cat(paste0("Correlation between future entropy score and mean expression: ", as.character(cor(sr.v.fut, mean.expr.v))))
  cat("\n")
  # compute the correlation between SR score and median of expressed genes
  cat(paste0("Correlation between observed entropy score and median expression: ", as.character(cor(sr.v.obs, median.expr.v))))
  cat("\n")
  cat(paste0("Correlation between future entropy score and median expression: ", as.character(cor(sr.v.fut, median.expr.v))))
  cat("\n")

  ## DOTPLOT ####
  if ("Potency_states_observed" %in% names(adata$obs)) {
    cat("Dotplot of potency states...")
    cat("\n")
    library(ggplot2)
    library(reshape2)
    library(scales)
    pdf(paste0(project_dir, "/signaling_entropy_plots/Dotplot_potency_states.pdf"), useDingbats=FALSE)
    for (i in 1:length(pheno.v)) {
      a.obs <- data.frame(POT=adata$obs['Potency_states_observed'][,'Potency_states_observed'], PHENO=pheno.v[[i]], ENT=sr.v.obs)
      a.fut <- data.frame(POT=adata$obs['Potency_states_future'][,'Potency_states_future'], PHENO=pheno.v[[i]], ENT=sr.v.fut)
      df_sr.obs <- aggregate(a.obs$ENT, list(a.obs$PHENO, a.obs$POT), median)
      df_sr.fut <- aggregate(a.fut$ENT, list(a.fut$PHENO, a.fut$POT), median)
      df_count.obs <- aggregate(a.obs$POT, list(a.obs$PHENO, a.obs$POT), length)
      df_count.fut <- aggregate(a.fut$POT, list(a.fut$PHENO, a.fut$POT), length)
      df_dataset.obs <- data.frame(df_count.obs, df_sr.obs$x)
      df_dataset.fut <- data.frame(df_count.fut, df_sr.fut$x)
      pheno_labels_a<-levels(pheno.v[[i]])
      p.obs <- ggplot(df_dataset.obs, aes(x=factor(Group.2), y=Group.1, size=x, color=df_sr.obs.x)) + geom_point() +
        labs(title="Dotplot of observed potency states", x ="Potency states", y = phenotype_annotation[i], size="nCells", color=" medSR")+
        scale_y_discrete(labels= pheno_labels_a)+
        scale_color_continuous(type='viridis', space = "Lab", limits=c(min(sr.v.obs),max(sr.v.obs)))+
        scale_x_discrete(breaks=1:length(names(table(adata$obs['Potency_states_observed']))),labels=names(table(adata$obs['Potency_states_observed'])))+
        scale_size_continuous(range = c(1,10), breaks=c(100,200,300,400,500))+
        theme_bw()+
        theme(panel.grid=element_blank(), axis.title.y = element_blank(), plot.title = element_text(hjust = 0.5))
      p.fut <- ggplot(df_dataset.fut, aes(x=factor(Group.2), y=Group.1, size=x, color=df_sr.fut.x)) + geom_point() +
        labs(title="Dotplot of future potency states", x ="Potency states", y = phenotype_annotation[i], size="nCells", color=" medSR")+
        scale_y_discrete(labels= pheno_labels_a)+
        scale_color_continuous(type='viridis', space = "Lab", limits=c(min(sr.v.fut),max(sr.v.fut)))+
        scale_x_discrete(breaks=1:length(names(table(adata$obs['Potency_states_future']))),labels=names(table(adata$obs['Potency_states_future'])))+
        scale_size_continuous(range = c(1,10), breaks=c(100,200,300,400,500))+
        theme_bw()+
        theme(panel.grid=element_blank(), axis.title.y = element_blank(), plot.title = element_text(hjust = 0.5))
      print(p.obs)
      print(p.fut)
    }
    dev.off()
  }

  pheno.a <- list()
  for (i in 1:length(phenotype_colors)) {
    pheno.a[[i]] <- levels(pheno.v[[i]])
    names(pheno.a[[i]]) <- phenotype_colors[[i]]
  }

  for (i in 1:length(phenotype_annotation)) {
    col_i <- NULL
    if (!is.null(phenotype_order) & !is.null(phenotype_order[[i]])) {
      c_ord_i <- phenotype_order[[i]]
    } else {
      c_ord_i <- names(table(adata$obs[phenotype_annotation[i]][,phenotype_annotation[i]]))
    }
    for (j in c_ord_i) {
      col_i <- c(col_i, names(pheno.a[[i]])[pheno.a[[i]]==j])
    }
    set_annot_levels(adata, c_as=phenotype_annotation[i], c_ord=c_ord_i, pal=col_i)
  }

}

#' @title compute_entropy_UMAP
#'
#' @description Computes UMAP embeddings from observed entropies with Scanpy. First, a PCA is performed directly on entropy values, then a nearest neighbor graph is computed from resulting PCs, and finally the UMAP embedding is built on the neighbor graph. Optionally, a clustering analysis is also performed on the neighbor graph. The user can specify any combination of PCs and neighbors for UMAP computation, the results will be saved into separate folders
#'
#' @param adata anndata object with "partial_entropies_observed" layer (produced by the "compute_signaling_entropy" function)
#' @param project_dir name of the directory containing the results of the main FIERCE analysis (including the path). If it does not exist, it will be created. The default name is "./FIERCE_results". The UMAP plots will be saved in the "UMAP_from_entropy" sub-directory, in separate folders for each combination of PCs and neighbors specified by the user
#' @param n_neighbors number of nearest neighbors to compute for each cell in the nearest neighbor graph that will be used for UMAP embedding computation. If the user wishes to try different values for this parameter, an integer vector containing all the desired values can be specified (the results will be saved into dedicated folders). Default is 30 neighbors
#' @param n_pcs number of PCs to consider for the nearest neighbor graph computation. If the user wishes to try different values for this parameter, an integer vector containing all the desired values can be specified (the results will be saved into dedicated folders). Default (NULL) is all the computed PCs (50). The PCs are computed directly from the observed entropies with the default PCA procedure of Scanpy
#' @param plot_PCA_heatmap boolean; whether to plot the heatmap of the entropies of the most significant genes for each PC. Default is TRUE
#' @param perform_clustering boolean; whether to perform clustering analysis on entropy values ("Leiden" algorithm). Default is FALSE. WARNING: a nearest neighbor graph must be computed first
#' @param color_as character vector containing the names of the cell annotations in the "obs" slot to visualize on the PCA and UMAP plots. If present, the results of the clustering analysis will be visualized by default
#' @param lab_order optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the order by which the respective labels should be printed in the legends of the PCA and UMAP plots. If it is not necessary to specify a particular order for a specific annotation, just write NULL. If it is not necessary to specify any order for any annotation, do not change the default value of this parameter
#' @param palette optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the colors of the respective labels. If it is not necessary to specify any color for a specific annotation, just write NULL; in this case, a default color palette will be used. If it is not necessary to specify any color for any annotation, do not change the default value of this parameter; in this case, annotations will be colored according either to a default palette, or to the colors that are already stored in the anndata object ("uns" slot)
#' @param legend_loc localization of the legend on the PCA and UMAP plots. Default is "right margin"
#' @param alpha transparency of the dots on the PCA and UMAP plots, ranging from 0 (fully transparent) to 1 (fully opaque). Default is 1
#' @param add_outline whether to add an outline around groups of dots on the PCA and UMAP plots. Default is FALSE
#' @param redo_from_scratch boolean, set it to TRUE to re-compute the PCs and UMAP coordinates and re-draw all the plots from scratch (otherwise, all the steps that have been already performed will be skipped if the function is launched a second time)
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis. In both cases, the PCs and the UMAP coordinates computed from observed entropies will be saved in the "obsm" slot. The nearest neighbor graph (the last that has been computed) will be saved in the "uns" and "obsp" slots
#'
#' @examples
#' #Compute UMAP embeddings from observed entropies with default parameters. Separate UMAP embeddings are computed with 10, 30 and 100 neighbors. Additionally, the neighbor graph is computed multiple times considering 15, 30 and 50 PCs. In this example, the clusters, the cell types and the cell cycle phase are visualized on the PCA and UMAP plots. A specific label order and a specific color for each label is specified for the cell cycle phase only
#'
#' compute_entropy_UMAP(adata, n_pcs=c(15,30,50), n_neighbors=c(10,30,100), color_as=c("clusters", "cell_types", "phase"), lab_order=list(NULL, NULL, c("G1","S","G2M")), palette=list(NULL, NULL, c("green", "red", "blue")), adata_copy=FALSE)
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#' @export
#'
#'

compute_entropy_UMAP <- function (adata, project_dir="./FIERCE_results", n_neighbors=30, n_pcs=NULL, plot_PCA_heatmap=TRUE, perform_clustering=FALSE, color_as=NULL, lab_order=NULL, palette=NULL, legend_loc="right margin", alpha=1, add_outline=FALSE, redo_from_scratch=FALSE, adata_copy=FALSE) {
  sc <- import("scanpy")
  ad <- import("anndata")

  if (dir.exists(project_dir) == FALSE) {
    dir.create(project_dir)
  }
  if (redo_from_scratch==TRUE) {
    if (check_uns(adata,"pca_entropy")=="Yes") {
      delete_uns(adata,"pca_entropy")
    }
    for (j in n_neighbors) {
	    for (i in n_pcs) {
        if (check_uns(adata,paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)))=="Yes") {
		      delete_uns(adata,paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)))
        }
	    }
    }
    if (dir.exists(paste0(project_dir, "/UMAP_from_entropy")) == TRUE) {
      unlink(paste0(project_dir, "/UMAP_from_entropy"), recursive=TRUE)
    }
  }
  if (dir.exists(paste0(project_dir, "/UMAP_from_entropy")) == FALSE) {
    dir.create(paste0(project_dir, "/UMAP_from_entropy"))
  }

  if (adata_copy==TRUE) {
    adata <- adata$copy()
  }

  if (is.null(color_as) & perform_clustering==TRUE) {
    color_as <- "leiden"
  }

  if (!is.null(palette) & !is.list(palette)) {
    stop("palette is not a list")
  }

  if (!is.null(lab_order) & !is.list(lab_order)) {
    stop("lab_order is not a list")
  }

  #########
  ###PCA###
  #########

  if (check_uns(adata, 'pca_entropy')=="No") {

  entropies_matrix <- adata$layers['partial_entropies_observed']
  rownames(entropies_matrix) <- adata$obs_names$tolist()
  colnames(entropies_matrix) <- adata$var_names$tolist()
  adata_temp <- ad$AnnData(entropies_matrix)

  cat("Performing PCA on local entropies...")
  cat("\n")

  sc$tl$pca(adata_temp, svd_solver='arpack')

  if (!("pca_variance_ratio_entropy.pdf"%in%dir(paste0(project_dir, "/UMAP_from_entropy")))) {
    sc$pl$pca_variance_ratio(adata_temp, log=TRUE, save='_entropy.pdf')
    move_plots(project_dir=project_dir, subfolder="UMAP_from_entropy")
  }
  if ((plot_PCA_heatmap==TRUE) & !("pca_heatmap_entropy.pdf"%in%dir(paste0(project_dir, "/UMAP_from_entropy")))) {
    if (dir.exists("figures") == FALSE) {
      dir.create("figures")
    }
    pca_heatmap(adata_temp, components=as.integer(ncol(adata_temp$obsm['X_pca'])), use_raw=NULL, filename="figures/pca_heatmap_entropy.pdf")
    move_plots(project_dir=project_dir, subfolder="UMAP_from_entropy")
  }

  add_uns(adata, adata_temp$uns['pca'], 'pca_entropy')
  add_obsm(adata, adata_temp$obsm['X_pca'], 'X_pca_entropy')
  add_varm(adata, adata_temp$varm['PCs'], 'PCs_entropy')
  rm(adata_temp)

  }

  cat("Plotting PCs...")
  cat("\n")

  if (is.null(color_as)) {
    if (!("pca_entropy.pdf"%in%dir(paste0(project_dir, "/UMAP_from_entropy")))) {
      draw_embedding(adata, file_name="_entropy", emb='pca_entropy', legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
    }
  } else {
    for (i in 1:length(color_as)) {
      if (!(paste0("pca_entropy_", color_as[i], ".pdf")%in%dir(paste0(project_dir, "/UMAP_from_entropy")))) {
      if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("character","factor")) {
        c_type_i <- "categorical"
      } else if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("integer","numeric")) {
        c_type_i <- "numeric"
      }
      if (is.null(palette)) {
        pal_i <- NULL
      } else {
        pal_i <- palette[[i]]
      }
      if (is.null(lab_order)) {
        c_ord_i <- NULL
      } else {
        c_ord_i <- lab_order[[i]]
      }
      draw_embedding(adata, file_name=paste0("_entropy_", color_as[i]), emb='pca_entropy', c_as=color_as[i], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
      }
    }
  }
  move_plots(project_dir=project_dir, subfolder="UMAP_from_entropy")

  ##########
  ###UMAP###
  ##########

  if (is.null(n_neighbors)) {
    n_neighbors <- 30
  }

  if (is.null(n_pcs)) {
    n_pcs <- ncol(adata$obsm['X_pca_entropy'])
  }

  cat("Performing UMAP...")
  cat("\n")

  entropies_matrix <- adata$layers['partial_entropies_observed']
  rownames(entropies_matrix) <- adata$obs_names$tolist()
  colnames(entropies_matrix) <- adata$var_names$tolist()
  adata_temp <- ad$AnnData(entropies_matrix)
  add_uns(adata_temp, adata$uns['pca_entropy'], 'pca')
  add_obsm(adata_temp, adata$obsm['X_pca_entropy'], 'X_pca')
  add_varm(adata_temp, adata$varm['PCs_entropy'], 'PCs')

  for (j in n_neighbors) {

  for (i in n_pcs) {

  if (check_uns(adata,paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)))=="No") {

  sc$pp$neighbors(adata_temp, n_neighbors=as.integer(j), n_pcs=as.integer(i))

  sc$tl$umap(adata_temp)
  add_uns(adata, adata_temp$uns['umap'], paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)))
  add_obsm(adata, adata_temp$obsm['X_umap'], paste0('X_umap_entropy_n', as.character(j), 'pc', as.character(i)))

  if (perform_clustering==TRUE) {
    sc$tl$leiden(adata_temp)
    add_uns(adata, adata_temp$uns['leiden'], paste0('leiden_entropy_n', as.character(j), 'pc', as.character(i)))
    add_annotation_obs(adata, adata_temp$obs['leiden']$leiden, paste0('leiden_entropy_n', as.character(j), 'pc', as.character(i)))
    add_annotation_obs(adata, as.factor(adata$obs['leiden']$leiden), paste0('leiden_entropy_n', as.character(j), 'pc', as.character(i)))
  }

  }

  }

  }

  if (check_uns(adata_temp,'neighbors')=="Yes") {
    add_uns(adata, adata_temp$uns['neighbors'], 'neighbors')
    add_obsp(adata, adata_temp$obsp['connectivities'], 'connectivities')
    add_obsp(adata, adata_temp$obsp['distances'], 'distances')
  }

  rm(adata_temp)

  cat("Plotting UMAP results...")
  cat("\n")

  for (j in n_neighbors) {

  for (i in n_pcs) {

  if (dir.exists(paste0(project_dir, "/UMAP_from_entropy/", 'n', as.character(j), 'pc', as.character(i))) == FALSE) {
  dir.create(paste0(project_dir, "/UMAP_from_entropy/", 'n', as.character(j), 'pc', as.character(i)))
  }

  current_dir <- paste0(project_dir, "/UMAP_from_entropy/", 'n', as.character(j), 'pc', as.character(i))

  if (is.null(color_as)) {
    if (!(paste0("umap_entropy_n", as.character(j), "pc", as.character(i), ".pdf")%in%dir(current_dir))) {
      draw_embedding(adata, file_name=paste0("_entropy_n", as.character(j), "pc", as.character(i)), emb=paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)), legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
    }
  } else {
    for (k in 1:length(color_as)) {
      if (!(paste0("umap_entropy_", color_as[k], "_n", as.character(j), "pc", as.character(i), ".pdf")%in%dir(current_dir))) {
      if (class(adata$obs[color_as[k]][,color_as[k]]) %in% c("character","factor")) {
        c_type_i <- "categorical"
      } else if (class(adata$obs[color_as[k]][,color_as[k]]) %in% c("integer","numeric")) {
        c_type_i <- "numeric"
      }
      if (is.null(palette)) {
        pal_i <- NULL
      } else {
        pal_i <- palette[[k]]
      }
      if (is.null(lab_order)) {
        c_ord_i <- NULL
      } else {
        c_ord_i <- lab_order[[k]]
      }
      draw_embedding(adata, file_name=paste0("_entropy_", color_as[k], "_n", as.character(j), "pc", as.character(i)), emb=paste0('umap_entropy_n', as.character(j), 'pc', as.character(i)), c_as=color_as[k], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline)
      }
    }
  }
  move_plots(project_dir=project_dir, subfolder=paste0("UMAP_from_entropy/", 'n', as.character(j), 'pc', as.character(i)))

  }

  }

  cat("Removed temporary figures directory")
  cat("\n")

  if (adata_copy==TRUE) {
    return(adata)
  }
}


#' @title compute_graph_and_stream
#'
#' @description Computes the cell-cell transition probabilites based on the correlation of the velocities of the entropy of each cell with the entropies of neighboring cells. Then, based on such probabilites, draws the streamplot on an embedding of choice (the default is UMAP). scVelo has been adapted to perform all the computation
#'
#' @param adata anndata object with "partial_entropies_observed" and "velocity_of_the_entropy" layers (produced by the "compute_signaling_entropy" function)
#' @param project_dir name of the directory containing the results of the main FIERCE analysis (including the path). If it does not exist, it will be created. The default name is "./FIERCE_results". The streamplot will be saved in the "velocity_field_streamplots" sub-directory
#' @param only_velocity_genes boolean; whether only the genes that successfully fitted the velocity dynamical model ("compute_velocity" function) should be used for transition probabilities computation. Default is FALSE
#' @param n_neighbors_graph this parameter, in combination with "n_pcs_graph", specifies which nearest neighbors graph will be used to compute the cell-cell transition probabilities on the entropy space. By default, it has the same value of n_neighbors_emb 
#' @param n_pcs_graph this parameter, in combination with "n_neighbors_graph", specifies which nearest neighbors graph will be used to compute the cell-cell transition probabilities on the entropy space. By default, it has the same value of n_pcs_emb
#' @param n_neighbors_emb if "umap_entropy" is chosen as cell embedding for the streamplot, this parameter, in combination with "n_pcs_emb", specifies which embedding will be used among those that have been produced by the "compute_entropy_UMAP" function (stored in the "obsm" slot). If NULL (default), the last computed embedding will be used
#' @param n_pcs_emb if "umap_entropy" is chosen as cell embedding for the streamplot, this parameter, in combination with "n_neighbors_emb", specifies which embedding will be used among those that have been produced by the "compute_entropy_UMAP" function (stored in the "obsm" slot). If NULL (default), the last computed embedding will be used
#' @param sqrt_transform boolean; whether to apply the variance-stabilizing transformation during transition probabilities computation. It helps to obtain a smoother streamplot. Default is TRUE
#' @param embedding_basis name of the embedding to use for the streamplot. Default is "umap_entropy"
#' @param force_graph_recalc whether to force the recalculation of the cell-cell transition probabilities matrix, if already present. Default is TRUE
#' @param color_as character vector containing the names of the cell annotations in the "obs" slot to visualize on the streamplot
#' @param lab_order optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the order by which the respective labels should be printed in the legends of the streamplots. If it is not necessary to specify a particular order for a specific annotation, just write NULL. If it is not necessary to specify any order for any annotation, do not change the default value of this parameter
#' @param palette optional; list containing, for each cell annotation specified in "color_as", a character vector specifying the colors of the respective labels. If it is not necessary to specify any color for a specific annotation, just write NULL; in this case, a default color palette will be used. If it is not necessary to specify any color for any annotation, do not change the default value of this parameter; in this case, annotations will be colored according either to a default palette, or to the colors that are already stored in the anndata object ("uns" slot)
#' @param legend_loc localization of the legend on the streamplot. Default is "right margin"
#' @param alpha transparency of the dots on the streamplots, ranging from 0 (fully transparent) to 1 (fully opaque). Default is 0.3
#' @param add_outline whether to add an outline around groups of dots on the streamplots. Default is TRUE
#' @param min_mass minimum magnitude required for velocity vectors to be drawn on the streamplot, ranging from 0 (all vectors) to 5 (most intense vectors only). Default is 4
#' @param n_cores number of cores to use to compute the cell-cell transition probability matrix (most computationally expensive step). If NULL (default), only 1 will be used
#' @param adata_copy boolean; if TRUE, create a new anndata object with the results of the analysis; if FALSE, update the provided anndata object. Default is FALSE
#'
#' @return If adata_copy=TRUE, a new anndata object with the results of the analysis will be returned. Otherwise (default), the provided anndata object will be updated with the results of the analysis. In both cases, the velocity graph (correlations used for transition probabilities computation) will be saved in the "uns" slot, and the predicted displacements of cells (used for streamplot drawing) will be saved in the "obsm" slot
#'
#' @examples
#' #Draw the streamplot on the UMAP embedding by using all genes for transition probabilities computation. The last entropy-based embedding computed by the "compute_entropy_UMAP" function is used. In this example, the clusters, the cell types and the cell cycle phase are visualized on the streamplot. A specific label order and a specific color for each label is specified for the cell cycle phase only
#'
#' compute_graph_and_stream(adata, color_as=c("clusters", "cell_types", "phase"), lab_order=list(NULL, NULL, c("G1","S","G2M")), palette=list(NULL, NULL, c("green", "red", "blue")))
#'
#' #Draw the streamplot on the UMAP embedding by using only the best fit velocity genes for transition probabilities computation, and without the variance stabilizing transformation. The last entropy-based embedding computed by the "compute_entropy_UMAP" function is used. In this example, the clusters, the cell types and the cell cycle phase are visualized on the streamplot. A specific label order and a specific color for each label is specified for the cell cycle phase only
#'
#' compute_graph_and_stream(adata, only_velocity_genes=TRUE, sqrt_transform=FALSE, color_as=c("clusters", "cell_types", "phase"), lab_order=list(NULL, NULL, c("G1","S","G2M")), palette=list(NULL, NULL, c("green", "red", "blue")))
#'
#' #Draw the streamplot on the UMAP embedding by using all genes for transition probabilities computation. A specific entropy-derived UMAP embedding (30 neighbors and 30 PCs) is used. In this example, the clusters, the cell types and the cell cycle phase are visualized on the streamplot. A specific label order and a specific color for each label is specified for the cell cycle phase only. The results are saved in a new anndata object
#'
#' adata_streamplot <- compute_graph_and_stream(adata, n_neighbors_emb=30, n_pcs_emb=30, color_as=c("clusters", "cell_types", "phase"), lab_order=list(NULL, NULL, c("G1","S","G2M")), palette=list(NULL, NULL, c("green", "red", "blue")), adata_copy=FALSE)
#'
#' @exportPattern "^[[:alpha:]]+"
#' @importFrom magrittr "%>%"
#' @export
#'
#'

compute_graph_and_stream <- function(adata, project_dir="./FIERCE_results", only_velocity_genes=FALSE, n_neighbors_graph=NULL, n_pcs_graph=NULL, n_neighbors_emb=NULL, n_pcs_emb=NULL, sqrt_transform=TRUE, embedding_basis='umap_entropy', force_graph_recalc=TRUE, color_as='total_entropies_observed', lab_order=NULL, palette=NULL, legend_loc='right margin', alpha=0.3, add_outline=TRUE, min_mass=4, n_cores=NULL, adata_copy=FALSE) {
  scv <- import("scvelo")

  if (dir.exists(project_dir) == FALSE) {
    dir.create(project_dir)
  }
  if (dir.exists(paste0(project_dir, "/velocity_field_streamplots")) == FALSE) {
    dir.create(paste0(project_dir, "/velocity_field_streamplots"))
  }

  if (adata_copy==TRUE) {
    adata <- adata$copy()
  }

  cat("Now printing scVelo output messages...")
  cat("\n")

  if (is.null(n_pcs_emb) | is.null(n_neighbors_emb)) {
    obsm_list <- extract_obsm_keys(adata)
    last_obsm <- obsm_list[grep("X_umap_entropy",obsm_list)][length(obsm_list[grep("X_umap_entropy",obsm_list)])]
    placeholder <- unlist(strsplit(last_obsm,split="_"))[length(unlist(strsplit(last_obsm,split="_")))]
    placeholder <- unlist(strsplit(placeholder,split="pc"))
    placeholder <- unlist(strsplit(placeholder,split="n"))
    n_neighbors_emb <- placeholder[2]
    n_pcs_emb <- placeholder[3]
  }

  if (force_graph_recalc==TRUE) {

  if (is.null(n_neighbors_graph)) {
    n_neighbors_graph <- n_neighbors_emb
  }

  if (is.null(n_pcs_graph)) {
    n_pcs_graph <- n_pcs_emb
  }

  adata_temp <- adata$copy()
  add_obsm(adata_temp, adata_temp$obsm['X_pca_entropy'], 'X_pca')
  scv$pp$neighbors(adata_temp, n_neighbors=as.integer(n_neighbors_graph), n_pcs=as.integer(n_pcs_graph))
  add_uns(adata, adata_temp$uns['neighbors'], 'neighbors')
  add_obsp(adata, adata_temp$obsp['connectivities'], 'connectivities')
  add_obsp(adata, adata_temp$obsp['distances'], 'distances')
  rm(adata_temp)


  if (only_velocity_genes==FALSE) {
    gene_subset <- adata$var_names$tolist()
  } else {
    gene_subset <- adata$var_names$tolist()[adata$var['velocity_genes']$velocity_genes == TRUE]
  }

  if (!is.null(n_cores)) {
    n_cores <- as.integer(n_cores)
  }
  scv$tl$velocity_graph(adata, gene_subset=gene_subset, vkey='velocity_of_the_entropy', xkey='partial_entropies_observed', sqrt_transform=sqrt_transform, n_jobs=n_cores)

  }

  if (!is.null(palette) & !is.list(palette)) {
    stop("palette is not a list")
  }

  if (!is.null(lab_order) & !is.list(lab_order)) {
    stop("lab_order is not a list")
  }

  if (embedding_basis=="umap_entropy") {
    embedding_basis <- paste0(embedding_basis, '_n', as.character(n_neighbors_emb), 'pc', as.character(n_pcs_emb))
  }
  if (is.null(color_as)) {
    draw_embedding(adata, file_name=paste0(embedding_basis, "_streamplot_FIERCE"), emb=embedding_basis, stream=TRUE, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline, min_mass=min_mass)
  } else {
    for (i in 1:length(color_as)) {
      if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("character","factor")) {
        c_type_i <- "categorical"
      } else if (class(adata$obs[color_as[i]][,color_as[i]]) %in% c("integer","numeric")) {
        c_type_i <- "numeric"
      }
      if (is.null(palette)) {
        pal_i <- NULL
      } else {
        pal_i <- palette[[i]]
      }
      if (is.null(lab_order)) {
        c_ord_i <- NULL
      } else {
        c_ord_i <- lab_order[[i]]
      }
      draw_embedding(adata, file_name=paste0(embedding_basis, "_streamplot_FIERCE_", color_as[i]), emb=embedding_basis, stream=TRUE, c_as=color_as[i], c_type=c_type_i, pal=pal_i, c_ord=c_ord_i, legend_loc=legend_loc, alpha=alpha, add_outline=add_outline, min_mass=min_mass)
    }
  }
  move_plots(project_dir=project_dir, subfolder="velocity_field_streamplots")
  rename_plots(project_dir=project_dir, subfolder="velocity_field_streamplots")

  cat("Removed temporary figures directory")
  cat("\n")
  
  if (adata_copy==TRUE) {
    return(adata)
  }
}


